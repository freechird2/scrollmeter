{"version":3,"file":"index.mjs","sources":["../../node_modules/html-to-image/es/util.js","../../node_modules/html-to-image/es/clone-pseudos.js","../../node_modules/html-to-image/es/mimes.js","../../node_modules/html-to-image/es/dataurl.js","../../node_modules/html-to-image/es/clone-node.js","../../node_modules/html-to-image/es/embed-resources.js","../../node_modules/html-to-image/es/embed-images.js","../../node_modules/html-to-image/es/apply-style.js","../../node_modules/html-to-image/es/embed-webfonts.js","../../node_modules/html-to-image/es/index.js","../src/types/scrollmeter.types.ts","../src/class/scrollmeter-tooltip.ts","../src/class/scrollmeter-timeline.ts","../src/class/scrollmeter.ts","../src/index.ts"],"sourcesContent":["export function resolveUrl(url, baseUrl) {\n    // url is absolute already\n    if (url.match(/^[a-z]+:\\/\\//i)) {\n        return url;\n    }\n    // url is absolute already, without protocol\n    if (url.match(/^\\/\\//)) {\n        return window.location.protocol + url;\n    }\n    // dataURI, mailto:, tel:, etc.\n    if (url.match(/^[a-z]+:/i)) {\n        return url;\n    }\n    const doc = document.implementation.createHTMLDocument();\n    const base = doc.createElement('base');\n    const a = doc.createElement('a');\n    doc.head.appendChild(base);\n    doc.body.appendChild(a);\n    if (baseUrl) {\n        base.href = baseUrl;\n    }\n    a.href = url;\n    return a.href;\n}\nexport const uuid = (() => {\n    // generate uuid for className of pseudo elements.\n    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.\n    let counter = 0;\n    // ref: http://stackoverflow.com/a/6248722/2519373\n    const random = () => \n    // eslint-disable-next-line no-bitwise\n    `0000${((Math.random() * 36 ** 4) << 0).toString(36)}`.slice(-4);\n    return () => {\n        counter += 1;\n        return `u${random()}${counter}`;\n    };\n})();\nexport function delay(ms) {\n    return (args) => new Promise((resolve) => {\n        setTimeout(() => resolve(args), ms);\n    });\n}\nexport function toArray(arrayLike) {\n    const arr = [];\n    for (let i = 0, l = arrayLike.length; i < l; i++) {\n        arr.push(arrayLike[i]);\n    }\n    return arr;\n}\nfunction px(node, styleProperty) {\n    const win = node.ownerDocument.defaultView || window;\n    const val = win.getComputedStyle(node).getPropertyValue(styleProperty);\n    return val ? parseFloat(val.replace('px', '')) : 0;\n}\nfunction getNodeWidth(node) {\n    const leftBorder = px(node, 'border-left-width');\n    const rightBorder = px(node, 'border-right-width');\n    return node.clientWidth + leftBorder + rightBorder;\n}\nfunction getNodeHeight(node) {\n    const topBorder = px(node, 'border-top-width');\n    const bottomBorder = px(node, 'border-bottom-width');\n    return node.clientHeight + topBorder + bottomBorder;\n}\nexport function getImageSize(targetNode, options = {}) {\n    const width = options.width || getNodeWidth(targetNode);\n    const height = options.height || getNodeHeight(targetNode);\n    return { width, height };\n}\nexport function getPixelRatio() {\n    let ratio;\n    let FINAL_PROCESS;\n    try {\n        FINAL_PROCESS = process;\n    }\n    catch (e) {\n        // pass\n    }\n    const val = FINAL_PROCESS && FINAL_PROCESS.env\n        ? FINAL_PROCESS.env.devicePixelRatio\n        : null;\n    if (val) {\n        ratio = parseInt(val, 10);\n        if (Number.isNaN(ratio)) {\n            ratio = 1;\n        }\n    }\n    return ratio || window.devicePixelRatio || 1;\n}\n// @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size\nconst canvasDimensionLimit = 16384;\nexport function checkCanvasDimensions(canvas) {\n    if (canvas.width > canvasDimensionLimit ||\n        canvas.height > canvasDimensionLimit) {\n        if (canvas.width > canvasDimensionLimit &&\n            canvas.height > canvasDimensionLimit) {\n            if (canvas.width > canvas.height) {\n                canvas.height *= canvasDimensionLimit / canvas.width;\n                canvas.width = canvasDimensionLimit;\n            }\n            else {\n                canvas.width *= canvasDimensionLimit / canvas.height;\n                canvas.height = canvasDimensionLimit;\n            }\n        }\n        else if (canvas.width > canvasDimensionLimit) {\n            canvas.height *= canvasDimensionLimit / canvas.width;\n            canvas.width = canvasDimensionLimit;\n        }\n        else {\n            canvas.width *= canvasDimensionLimit / canvas.height;\n            canvas.height = canvasDimensionLimit;\n        }\n    }\n}\nexport function canvasToBlob(canvas, options = {}) {\n    if (canvas.toBlob) {\n        return new Promise((resolve) => {\n            canvas.toBlob(resolve, options.type ? options.type : 'image/png', options.quality ? options.quality : 1);\n        });\n    }\n    return new Promise((resolve) => {\n        const binaryString = window.atob(canvas\n            .toDataURL(options.type ? options.type : undefined, options.quality ? options.quality : undefined)\n            .split(',')[1]);\n        const len = binaryString.length;\n        const binaryArray = new Uint8Array(len);\n        for (let i = 0; i < len; i += 1) {\n            binaryArray[i] = binaryString.charCodeAt(i);\n        }\n        resolve(new Blob([binaryArray], {\n            type: options.type ? options.type : 'image/png',\n        }));\n    });\n}\nexport function createImage(url) {\n    return new Promise((resolve, reject) => {\n        const img = new Image();\n        img.decode = () => resolve(img);\n        img.onload = () => resolve(img);\n        img.onerror = reject;\n        img.crossOrigin = 'anonymous';\n        img.decoding = 'async';\n        img.src = url;\n    });\n}\nexport async function svgToDataURL(svg) {\n    return Promise.resolve()\n        .then(() => new XMLSerializer().serializeToString(svg))\n        .then(encodeURIComponent)\n        .then((html) => `data:image/svg+xml;charset=utf-8,${html}`);\n}\nexport async function nodeToDataURL(node, width, height) {\n    const xmlns = 'http://www.w3.org/2000/svg';\n    const svg = document.createElementNS(xmlns, 'svg');\n    const foreignObject = document.createElementNS(xmlns, 'foreignObject');\n    svg.setAttribute('width', `${width}`);\n    svg.setAttribute('height', `${height}`);\n    svg.setAttribute('viewBox', `0 0 ${width} ${height}`);\n    foreignObject.setAttribute('width', '100%');\n    foreignObject.setAttribute('height', '100%');\n    foreignObject.setAttribute('x', '0');\n    foreignObject.setAttribute('y', '0');\n    foreignObject.setAttribute('externalResourcesRequired', 'true');\n    svg.appendChild(foreignObject);\n    foreignObject.appendChild(node);\n    return svgToDataURL(svg);\n}\nexport const isInstanceOfElement = (node, instance) => {\n    if (node instanceof instance)\n        return true;\n    const nodePrototype = Object.getPrototypeOf(node);\n    if (nodePrototype === null)\n        return false;\n    return (nodePrototype.constructor.name === instance.name ||\n        isInstanceOfElement(nodePrototype, instance));\n};\n//# sourceMappingURL=util.js.map","import { uuid, toArray } from './util';\nfunction formatCSSText(style) {\n    const content = style.getPropertyValue('content');\n    return `${style.cssText} content: '${content.replace(/'|\"/g, '')}';`;\n}\nfunction formatCSSProperties(style) {\n    return toArray(style)\n        .map((name) => {\n        const value = style.getPropertyValue(name);\n        const priority = style.getPropertyPriority(name);\n        return `${name}: ${value}${priority ? ' !important' : ''};`;\n    })\n        .join(' ');\n}\nfunction getPseudoElementStyle(className, pseudo, style) {\n    const selector = `.${className}:${pseudo}`;\n    const cssText = style.cssText\n        ? formatCSSText(style)\n        : formatCSSProperties(style);\n    return document.createTextNode(`${selector}{${cssText}}`);\n}\nfunction clonePseudoElement(nativeNode, clonedNode, pseudo) {\n    const style = window.getComputedStyle(nativeNode, pseudo);\n    const content = style.getPropertyValue('content');\n    if (content === '' || content === 'none') {\n        return;\n    }\n    const className = uuid();\n    try {\n        clonedNode.className = `${clonedNode.className} ${className}`;\n    }\n    catch (err) {\n        return;\n    }\n    const styleElement = document.createElement('style');\n    styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));\n    clonedNode.appendChild(styleElement);\n}\nexport function clonePseudoElements(nativeNode, clonedNode) {\n    clonePseudoElement(nativeNode, clonedNode, ':before');\n    clonePseudoElement(nativeNode, clonedNode, ':after');\n}\n//# sourceMappingURL=clone-pseudos.js.map","const WOFF = 'application/font-woff';\nconst JPEG = 'image/jpeg';\nconst mimes = {\n    woff: WOFF,\n    woff2: WOFF,\n    ttf: 'application/font-truetype',\n    eot: 'application/vnd.ms-fontobject',\n    png: 'image/png',\n    jpg: JPEG,\n    jpeg: JPEG,\n    gif: 'image/gif',\n    tiff: 'image/tiff',\n    svg: 'image/svg+xml',\n    webp: 'image/webp',\n};\nfunction getExtension(url) {\n    const match = /\\.([^./]*?)$/g.exec(url);\n    return match ? match[1] : '';\n}\nexport function getMimeType(url) {\n    const extension = getExtension(url).toLowerCase();\n    return mimes[extension] || '';\n}\n//# sourceMappingURL=mimes.js.map","function getContentFromDataUrl(dataURL) {\n    return dataURL.split(/,/)[1];\n}\nexport function isDataUrl(url) {\n    return url.search(/^(data:)/) !== -1;\n}\nexport function makeDataUrl(content, mimeType) {\n    return `data:${mimeType};base64,${content}`;\n}\nexport async function fetchAsDataURL(url, init, process) {\n    const res = await fetch(url, init);\n    if (res.status === 404) {\n        throw new Error(`Resource \"${res.url}\" not found`);\n    }\n    const blob = await res.blob();\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onerror = reject;\n        reader.onloadend = () => {\n            try {\n                resolve(process({ res, result: reader.result }));\n            }\n            catch (error) {\n                reject(error);\n            }\n        };\n        reader.readAsDataURL(blob);\n    });\n}\nconst cache = {};\nfunction getCacheKey(url, contentType, includeQueryParams) {\n    let key = url.replace(/\\?.*/, '');\n    if (includeQueryParams) {\n        key = url;\n    }\n    // font resource\n    if (/ttf|otf|eot|woff2?/i.test(key)) {\n        key = key.replace(/.*\\//, '');\n    }\n    return contentType ? `[${contentType}]${key}` : key;\n}\nexport async function resourceToDataURL(resourceUrl, contentType, options) {\n    const cacheKey = getCacheKey(resourceUrl, contentType, options.includeQueryParams);\n    if (cache[cacheKey] != null) {\n        return cache[cacheKey];\n    }\n    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache\n    if (options.cacheBust) {\n        // eslint-disable-next-line no-param-reassign\n        resourceUrl += (/\\?/.test(resourceUrl) ? '&' : '?') + new Date().getTime();\n    }\n    let dataURL;\n    try {\n        const content = await fetchAsDataURL(resourceUrl, options.fetchRequestInit, ({ res, result }) => {\n            if (!contentType) {\n                // eslint-disable-next-line no-param-reassign\n                contentType = res.headers.get('Content-Type') || '';\n            }\n            return getContentFromDataUrl(result);\n        });\n        dataURL = makeDataUrl(content, contentType);\n    }\n    catch (error) {\n        dataURL = options.imagePlaceholder || '';\n        let msg = `Failed to fetch resource: ${resourceUrl}`;\n        if (error) {\n            msg = typeof error === 'string' ? error : error.message;\n        }\n        if (msg) {\n            console.warn(msg);\n        }\n    }\n    cache[cacheKey] = dataURL;\n    return dataURL;\n}\n//# sourceMappingURL=dataurl.js.map","import { clonePseudoElements } from './clone-pseudos';\nimport { createImage, toArray, isInstanceOfElement } from './util';\nimport { getMimeType } from './mimes';\nimport { resourceToDataURL } from './dataurl';\nasync function cloneCanvasElement(canvas) {\n    const dataURL = canvas.toDataURL();\n    if (dataURL === 'data:,') {\n        return canvas.cloneNode(false);\n    }\n    return createImage(dataURL);\n}\nasync function cloneVideoElement(video, options) {\n    if (video.currentSrc) {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        canvas.width = video.clientWidth;\n        canvas.height = video.clientHeight;\n        ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(video, 0, 0, canvas.width, canvas.height);\n        const dataURL = canvas.toDataURL();\n        return createImage(dataURL);\n    }\n    const poster = video.poster;\n    const contentType = getMimeType(poster);\n    const dataURL = await resourceToDataURL(poster, contentType, options);\n    return createImage(dataURL);\n}\nasync function cloneIFrameElement(iframe) {\n    var _a;\n    try {\n        if ((_a = iframe === null || iframe === void 0 ? void 0 : iframe.contentDocument) === null || _a === void 0 ? void 0 : _a.body) {\n            return (await cloneNode(iframe.contentDocument.body, {}, true));\n        }\n    }\n    catch (_b) {\n        // Failed to clone iframe\n    }\n    return iframe.cloneNode(false);\n}\nasync function cloneSingleNode(node, options) {\n    if (isInstanceOfElement(node, HTMLCanvasElement)) {\n        return cloneCanvasElement(node);\n    }\n    if (isInstanceOfElement(node, HTMLVideoElement)) {\n        return cloneVideoElement(node, options);\n    }\n    if (isInstanceOfElement(node, HTMLIFrameElement)) {\n        return cloneIFrameElement(node);\n    }\n    return node.cloneNode(false);\n}\nconst isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === 'SLOT';\nasync function cloneChildren(nativeNode, clonedNode, options) {\n    var _a, _b;\n    let children = [];\n    if (isSlotElement(nativeNode) && nativeNode.assignedNodes) {\n        children = toArray(nativeNode.assignedNodes());\n    }\n    else if (isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n        ((_a = nativeNode.contentDocument) === null || _a === void 0 ? void 0 : _a.body)) {\n        children = toArray(nativeNode.contentDocument.body.childNodes);\n    }\n    else {\n        children = toArray(((_b = nativeNode.shadowRoot) !== null && _b !== void 0 ? _b : nativeNode).childNodes);\n    }\n    if (children.length === 0 ||\n        isInstanceOfElement(nativeNode, HTMLVideoElement)) {\n        return clonedNode;\n    }\n    await children.reduce((deferred, child) => deferred\n        .then(() => cloneNode(child, options))\n        .then((clonedChild) => {\n        if (clonedChild) {\n            clonedNode.appendChild(clonedChild);\n        }\n    }), Promise.resolve());\n    return clonedNode;\n}\nfunction cloneCSSStyle(nativeNode, clonedNode) {\n    const targetStyle = clonedNode.style;\n    if (!targetStyle) {\n        return;\n    }\n    const sourceStyle = window.getComputedStyle(nativeNode);\n    if (sourceStyle.cssText) {\n        targetStyle.cssText = sourceStyle.cssText;\n        targetStyle.transformOrigin = sourceStyle.transformOrigin;\n    }\n    else {\n        toArray(sourceStyle).forEach((name) => {\n            let value = sourceStyle.getPropertyValue(name);\n            if (name === 'font-size' && value.endsWith('px')) {\n                const reducedFont = Math.floor(parseFloat(value.substring(0, value.length - 2))) - 0.1;\n                value = `${reducedFont}px`;\n            }\n            if (isInstanceOfElement(nativeNode, HTMLIFrameElement) &&\n                name === 'display' &&\n                value === 'inline') {\n                value = 'block';\n            }\n            if (name === 'd' && clonedNode.getAttribute('d')) {\n                value = `path(${clonedNode.getAttribute('d')})`;\n            }\n            targetStyle.setProperty(name, value, sourceStyle.getPropertyPriority(name));\n        });\n    }\n}\nfunction cloneInputValue(nativeNode, clonedNode) {\n    if (isInstanceOfElement(nativeNode, HTMLTextAreaElement)) {\n        clonedNode.innerHTML = nativeNode.value;\n    }\n    if (isInstanceOfElement(nativeNode, HTMLInputElement)) {\n        clonedNode.setAttribute('value', nativeNode.value);\n    }\n}\nfunction cloneSelectValue(nativeNode, clonedNode) {\n    if (isInstanceOfElement(nativeNode, HTMLSelectElement)) {\n        const clonedSelect = clonedNode;\n        const selectedOption = Array.from(clonedSelect.children).find((child) => nativeNode.value === child.getAttribute('value'));\n        if (selectedOption) {\n            selectedOption.setAttribute('selected', '');\n        }\n    }\n}\nfunction decorate(nativeNode, clonedNode) {\n    if (isInstanceOfElement(clonedNode, Element)) {\n        cloneCSSStyle(nativeNode, clonedNode);\n        clonePseudoElements(nativeNode, clonedNode);\n        cloneInputValue(nativeNode, clonedNode);\n        cloneSelectValue(nativeNode, clonedNode);\n    }\n    return clonedNode;\n}\nasync function ensureSVGSymbols(clone, options) {\n    const uses = clone.querySelectorAll ? clone.querySelectorAll('use') : [];\n    if (uses.length === 0) {\n        return clone;\n    }\n    const processedDefs = {};\n    for (let i = 0; i < uses.length; i++) {\n        const use = uses[i];\n        const id = use.getAttribute('xlink:href');\n        if (id) {\n            const exist = clone.querySelector(id);\n            const definition = document.querySelector(id);\n            if (!exist && definition && !processedDefs[id]) {\n                // eslint-disable-next-line no-await-in-loop\n                processedDefs[id] = (await cloneNode(definition, options, true));\n            }\n        }\n    }\n    const nodes = Object.values(processedDefs);\n    if (nodes.length) {\n        const ns = 'http://www.w3.org/1999/xhtml';\n        const svg = document.createElementNS(ns, 'svg');\n        svg.setAttribute('xmlns', ns);\n        svg.style.position = 'absolute';\n        svg.style.width = '0';\n        svg.style.height = '0';\n        svg.style.overflow = 'hidden';\n        svg.style.display = 'none';\n        const defs = document.createElementNS(ns, 'defs');\n        svg.appendChild(defs);\n        for (let i = 0; i < nodes.length; i++) {\n            defs.appendChild(nodes[i]);\n        }\n        clone.appendChild(svg);\n    }\n    return clone;\n}\nexport async function cloneNode(node, options, isRoot) {\n    if (!isRoot && options.filter && !options.filter(node)) {\n        return null;\n    }\n    return Promise.resolve(node)\n        .then((clonedNode) => cloneSingleNode(clonedNode, options))\n        .then((clonedNode) => cloneChildren(node, clonedNode, options))\n        .then((clonedNode) => decorate(node, clonedNode))\n        .then((clonedNode) => ensureSVGSymbols(clonedNode, options));\n}\n//# sourceMappingURL=clone-node.js.map","import { resolveUrl } from './util';\nimport { getMimeType } from './mimes';\nimport { isDataUrl, makeDataUrl, resourceToDataURL } from './dataurl';\nconst URL_REGEX = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nconst URL_WITH_FORMAT_REGEX = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g;\nconst FONT_SRC_REGEX = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nfunction toRegex(url) {\n    // eslint-disable-next-line no-useless-escape\n    const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, '\\\\$1');\n    return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, 'g');\n}\nexport function parseURLs(cssText) {\n    const urls = [];\n    cssText.replace(URL_REGEX, (raw, quotation, url) => {\n        urls.push(url);\n        return raw;\n    });\n    return urls.filter((url) => !isDataUrl(url));\n}\nexport async function embed(cssText, resourceURL, baseURL, options, getContentFromUrl) {\n    try {\n        const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;\n        const contentType = getMimeType(resourceURL);\n        let dataURL;\n        if (getContentFromUrl) {\n            const content = await getContentFromUrl(resolvedURL);\n            dataURL = makeDataUrl(content, contentType);\n        }\n        else {\n            dataURL = await resourceToDataURL(resolvedURL, contentType, options);\n        }\n        return cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`);\n    }\n    catch (error) {\n        // pass\n    }\n    return cssText;\n}\nfunction filterPreferredFontFormat(str, { preferredFontFormat }) {\n    return !preferredFontFormat\n        ? str\n        : str.replace(FONT_SRC_REGEX, (match) => {\n            // eslint-disable-next-line no-constant-condition\n            while (true) {\n                const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];\n                if (!format) {\n                    return '';\n                }\n                if (format === preferredFontFormat) {\n                    return `src: ${src};`;\n                }\n            }\n        });\n}\nexport function shouldEmbed(url) {\n    return url.search(URL_REGEX) !== -1;\n}\nexport async function embedResources(cssText, baseUrl, options) {\n    if (!shouldEmbed(cssText)) {\n        return cssText;\n    }\n    const filteredCSSText = filterPreferredFontFormat(cssText, options);\n    const urls = parseURLs(filteredCSSText);\n    return urls.reduce((deferred, url) => deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText));\n}\n//# sourceMappingURL=embed-resources.js.map","import { embedResources } from './embed-resources';\nimport { toArray, isInstanceOfElement } from './util';\nimport { isDataUrl, resourceToDataURL } from './dataurl';\nimport { getMimeType } from './mimes';\nasync function embedProp(propName, node, options) {\n    var _a;\n    const propValue = (_a = node.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue(propName);\n    if (propValue) {\n        const cssString = await embedResources(propValue, null, options);\n        node.style.setProperty(propName, cssString, node.style.getPropertyPriority(propName));\n        return true;\n    }\n    return false;\n}\nasync function embedBackground(clonedNode, options) {\n    if (!(await embedProp('background', clonedNode, options))) {\n        await embedProp('background-image', clonedNode, options);\n    }\n    if (!(await embedProp('mask', clonedNode, options))) {\n        await embedProp('mask-image', clonedNode, options);\n    }\n}\nasync function embedImageNode(clonedNode, options) {\n    const isImageElement = isInstanceOfElement(clonedNode, HTMLImageElement);\n    if (!(isImageElement && !isDataUrl(clonedNode.src)) &&\n        !(isInstanceOfElement(clonedNode, SVGImageElement) &&\n            !isDataUrl(clonedNode.href.baseVal))) {\n        return;\n    }\n    const url = isImageElement ? clonedNode.src : clonedNode.href.baseVal;\n    const dataURL = await resourceToDataURL(url, getMimeType(url), options);\n    await new Promise((resolve, reject) => {\n        clonedNode.onload = resolve;\n        clonedNode.onerror = reject;\n        const image = clonedNode;\n        if (image.decode) {\n            image.decode = resolve;\n        }\n        if (image.loading === 'lazy') {\n            image.loading = 'eager';\n        }\n        if (isImageElement) {\n            clonedNode.srcset = '';\n            clonedNode.src = dataURL;\n        }\n        else {\n            clonedNode.href.baseVal = dataURL;\n        }\n    });\n}\nasync function embedChildren(clonedNode, options) {\n    const children = toArray(clonedNode.childNodes);\n    const deferreds = children.map((child) => embedImages(child, options));\n    await Promise.all(deferreds).then(() => clonedNode);\n}\nexport async function embedImages(clonedNode, options) {\n    if (isInstanceOfElement(clonedNode, Element)) {\n        await embedBackground(clonedNode, options);\n        await embedImageNode(clonedNode, options);\n        await embedChildren(clonedNode, options);\n    }\n}\n//# sourceMappingURL=embed-images.js.map","export function applyStyle(node, options) {\n    const { style } = node;\n    if (options.backgroundColor) {\n        style.backgroundColor = options.backgroundColor;\n    }\n    if (options.width) {\n        style.width = `${options.width}px`;\n    }\n    if (options.height) {\n        style.height = `${options.height}px`;\n    }\n    const manual = options.style;\n    if (manual != null) {\n        Object.keys(manual).forEach((key) => {\n            style[key] = manual[key];\n        });\n    }\n    return node;\n}\n//# sourceMappingURL=apply-style.js.map","import { toArray } from './util';\nimport { fetchAsDataURL } from './dataurl';\nimport { shouldEmbed, embedResources } from './embed-resources';\nconst cssFetchCache = {};\nasync function fetchCSS(url) {\n    let cache = cssFetchCache[url];\n    if (cache != null) {\n        return cache;\n    }\n    const res = await fetch(url);\n    const cssText = await res.text();\n    cache = { url, cssText };\n    cssFetchCache[url] = cache;\n    return cache;\n}\nasync function embedFonts(data, options) {\n    let cssText = data.cssText;\n    const regexUrl = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n    const fontLocs = cssText.match(/url\\([^)]+\\)/g) || [];\n    const loadFonts = fontLocs.map(async (loc) => {\n        let url = loc.replace(regexUrl, '$1');\n        if (!url.startsWith('https://')) {\n            url = new URL(url, data.url).href;\n        }\n        return fetchAsDataURL(url, options.fetchRequestInit, ({ result }) => {\n            cssText = cssText.replace(loc, `url(${result})`);\n            return [loc, result];\n        });\n    });\n    return Promise.all(loadFonts).then(() => cssText);\n}\nfunction parseCSS(source) {\n    if (source == null) {\n        return [];\n    }\n    const result = [];\n    const commentsRegex = /(\\/\\*[\\s\\S]*?\\*\\/)/gi;\n    // strip out comments\n    let cssText = source.replace(commentsRegex, '');\n    // eslint-disable-next-line prefer-regex-literals\n    const keyframesRegex = new RegExp('((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})', 'gi');\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const matches = keyframesRegex.exec(cssText);\n        if (matches === null) {\n            break;\n        }\n        result.push(matches[0]);\n    }\n    cssText = cssText.replace(keyframesRegex, '');\n    const importRegex = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n    // to match css & media queries together\n    const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n        '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})';\n    // unified regex\n    const unifiedRegex = new RegExp(combinedCSSRegex, 'gi');\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        let matches = importRegex.exec(cssText);\n        if (matches === null) {\n            matches = unifiedRegex.exec(cssText);\n            if (matches === null) {\n                break;\n            }\n            else {\n                importRegex.lastIndex = unifiedRegex.lastIndex;\n            }\n        }\n        else {\n            unifiedRegex.lastIndex = importRegex.lastIndex;\n        }\n        result.push(matches[0]);\n    }\n    return result;\n}\nasync function getCSSRules(styleSheets, options) {\n    const ret = [];\n    const deferreds = [];\n    // First loop inlines imports\n    styleSheets.forEach((sheet) => {\n        if ('cssRules' in sheet) {\n            try {\n                toArray(sheet.cssRules || []).forEach((item, index) => {\n                    if (item.type === CSSRule.IMPORT_RULE) {\n                        let importIndex = index + 1;\n                        const url = item.href;\n                        const deferred = fetchCSS(url)\n                            .then((metadata) => embedFonts(metadata, options))\n                            .then((cssText) => parseCSS(cssText).forEach((rule) => {\n                            try {\n                                sheet.insertRule(rule, rule.startsWith('@import')\n                                    ? (importIndex += 1)\n                                    : sheet.cssRules.length);\n                            }\n                            catch (error) {\n                                console.error('Error inserting rule from remote css', {\n                                    rule,\n                                    error,\n                                });\n                            }\n                        }))\n                            .catch((e) => {\n                            console.error('Error loading remote css', e.toString());\n                        });\n                        deferreds.push(deferred);\n                    }\n                });\n            }\n            catch (e) {\n                const inline = styleSheets.find((a) => a.href == null) || document.styleSheets[0];\n                if (sheet.href != null) {\n                    deferreds.push(fetchCSS(sheet.href)\n                        .then((metadata) => embedFonts(metadata, options))\n                        .then((cssText) => parseCSS(cssText).forEach((rule) => {\n                        inline.insertRule(rule, sheet.cssRules.length);\n                    }))\n                        .catch((err) => {\n                        console.error('Error loading remote stylesheet', err);\n                    }));\n                }\n                console.error('Error inlining remote css file', e);\n            }\n        }\n    });\n    return Promise.all(deferreds).then(() => {\n        // Second loop parses rules\n        styleSheets.forEach((sheet) => {\n            if ('cssRules' in sheet) {\n                try {\n                    toArray(sheet.cssRules || []).forEach((item) => {\n                        ret.push(item);\n                    });\n                }\n                catch (e) {\n                    console.error(`Error while reading CSS rules from ${sheet.href}`, e);\n                }\n            }\n        });\n        return ret;\n    });\n}\nfunction getWebFontRules(cssRules) {\n    return cssRules\n        .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n        .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')));\n}\nasync function parseWebFontRules(node, options) {\n    if (node.ownerDocument == null) {\n        throw new Error('Provided element is not within a Document');\n    }\n    const styleSheets = toArray(node.ownerDocument.styleSheets);\n    const cssRules = await getCSSRules(styleSheets, options);\n    return getWebFontRules(cssRules);\n}\nexport async function getWebFontCSS(node, options) {\n    const rules = await parseWebFontRules(node, options);\n    const cssTexts = await Promise.all(rules.map((rule) => {\n        const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;\n        return embedResources(rule.cssText, baseUrl, options);\n    }));\n    return cssTexts.join('\\n');\n}\nexport async function embedWebFonts(clonedNode, options) {\n    const cssText = options.fontEmbedCSS != null\n        ? options.fontEmbedCSS\n        : options.skipFonts\n            ? null\n            : await getWebFontCSS(clonedNode, options);\n    if (cssText) {\n        const styleNode = document.createElement('style');\n        const sytleContent = document.createTextNode(cssText);\n        styleNode.appendChild(sytleContent);\n        if (clonedNode.firstChild) {\n            clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n        }\n        else {\n            clonedNode.appendChild(styleNode);\n        }\n    }\n}\n//# sourceMappingURL=embed-webfonts.js.map","import { cloneNode } from './clone-node';\nimport { embedImages } from './embed-images';\nimport { applyStyle } from './apply-style';\nimport { embedWebFonts, getWebFontCSS } from './embed-webfonts';\nimport { getImageSize, getPixelRatio, createImage, canvasToBlob, nodeToDataURL, checkCanvasDimensions, } from './util';\nexport async function toSvg(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const clonedNode = (await cloneNode(node, options, true));\n    await embedWebFonts(clonedNode, options);\n    await embedImages(clonedNode, options);\n    applyStyle(clonedNode, options);\n    const datauri = await nodeToDataURL(clonedNode, width, height);\n    return datauri;\n}\nexport async function toCanvas(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const svg = await toSvg(node, options);\n    const img = await createImage(svg);\n    const canvas = document.createElement('canvas');\n    const context = canvas.getContext('2d');\n    const ratio = options.pixelRatio || getPixelRatio();\n    const canvasWidth = options.canvasWidth || width;\n    const canvasHeight = options.canvasHeight || height;\n    canvas.width = canvasWidth * ratio;\n    canvas.height = canvasHeight * ratio;\n    if (!options.skipAutoScale) {\n        checkCanvasDimensions(canvas);\n    }\n    canvas.style.width = `${canvasWidth}`;\n    canvas.style.height = `${canvasHeight}`;\n    if (options.backgroundColor) {\n        context.fillStyle = options.backgroundColor;\n        context.fillRect(0, 0, canvas.width, canvas.height);\n    }\n    context.drawImage(img, 0, 0, canvas.width, canvas.height);\n    return canvas;\n}\nexport async function toPixelData(node, options = {}) {\n    const { width, height } = getImageSize(node, options);\n    const canvas = await toCanvas(node, options);\n    const ctx = canvas.getContext('2d');\n    return ctx.getImageData(0, 0, width, height).data;\n}\nexport async function toPng(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    return canvas.toDataURL();\n}\nexport async function toJpeg(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    return canvas.toDataURL('image/jpeg', options.quality || 1);\n}\nexport async function toBlob(node, options = {}) {\n    const canvas = await toCanvas(node, options);\n    const blob = await canvasToBlob(canvas);\n    return blob;\n}\nexport async function getFontEmbedCSS(node, options = {}) {\n    return getWebFontCSS(node, options);\n}\n//# sourceMappingURL=index.js.map","export interface ScrollmeterTimelineOptions {\n  color?: string\n  width?: number\n}\n\nexport interface ScrollmeterBarOptions {\n  color?: string\n  background?: string\n  height?: number\n}\n\nexport interface ScrollmeterTooltipOptions {\n  background?: string\n  fontColor?: string\n  fontSize?: number\n  paddingBlock?: number\n  paddingInline?: number\n  width?: number\n}\n\nexport interface ScrollmeterOptions {\n  targetId: string\n  useTimeline?: boolean\n  useTooltip?: boolean\n  usePreview?: boolean\n  barOptions?: ScrollmeterBarOptions\n  timelineOptions?: ScrollmeterTimelineOptions\n  tooltipOptions?: ScrollmeterTooltipOptions\n}\n\nexport abstract class IScrollmeter {\n  protected abstract setCSSCustomProperties(): void\n}\n","import styles from '../styles/scrollmeter.module.scss'\nimport { IScrollmeter } from '../types/scrollmeter.types'\nimport { Scrollmeter } from './scrollmeter'\n\nexport class ScrollmeterTooltip extends IScrollmeter {\n    #scrollmeter: Scrollmeter\n\n    constructor(scrollmeter: Scrollmeter) {\n        super()\n        this.#scrollmeter = scrollmeter\n    }\n\n    #cropImageAtPercent = (targetElement: HTMLElement, cropWidth: number = 320) => {\n        const captureCanvas = this.#scrollmeter.getCaptureCanvas()\n\n        if (!captureCanvas) return\n\n        const canvasWidth = captureCanvas.width\n        const canvasHeight = (canvasWidth * 9) / 16 // 16:9 비율 계산\n        const y = Math.max(0, targetElement.getBoundingClientRect().top + window.scrollY - canvasHeight / 2)\n\n        const cropHeight = (cropWidth * 9) / 16 // 16:9 비율 계산\n\n        const tempCanvas = document.createElement('canvas')\n        tempCanvas.width = cropWidth\n        tempCanvas.height = cropHeight\n\n        const ctx = tempCanvas.getContext('2d')\n        if (!ctx) return null\n\n        // 크롭된 영역 그리기\n        ctx.drawImage(\n            captureCanvas,\n            0,\n            Math.max(0, Math.min(y, captureCanvas.height - canvasHeight)), // y값 범위 제한\n            canvasWidth,\n            canvasHeight,\n            0,\n            0,\n            cropWidth,\n            cropHeight\n        )\n\n        return tempCanvas.toDataURL()\n    }\n\n    #createPreview = (dataUrl: string) => {\n        const div = document.createElement('div')\n        div.classList.add(styles.scrollmeter_timeline_preview)\n\n        const img = new Image()\n\n        img.src = dataUrl\n\n        div.appendChild(img)\n        return div\n    }\n\n    public createTimelineTooltip = (\n        timelineElement: HTMLDivElement,\n        targetElement: HTMLElement,\n        direction: 'left' | 'right' | 'center'\n    ) => {\n        if (!targetElement.textContent) return\n        const timelineTooltip = document.createElement('div')\n        const timelineTooltipText = document.createElement('p')\n\n        if (this.#scrollmeter.getDefaultOptions().usePreview) {\n            const dataUrl = this.#cropImageAtPercent(targetElement)\n\n            if (dataUrl) {\n                const preview = this.#createPreview(dataUrl)\n                timelineTooltip.appendChild(preview)\n            }\n        }\n\n        timelineTooltip.classList.add(styles.scrollmeter_timeline_tooltip)\n        timelineTooltip.classList.add(styles[`scrollmeter_timeline_tooltip_${direction}`])\n\n        timelineTooltipText.textContent = targetElement.textContent\n\n        timelineTooltip.appendChild(timelineTooltipText)\n\n        this.setCSSCustomProperties()\n\n        timelineElement.appendChild(timelineTooltip)\n    }\n\n    protected setCSSCustomProperties() {\n        const defaultOptions = this.#scrollmeter.getDefaultOptions()\n\n        // css custom\n        if (defaultOptions && defaultOptions.tooltipOptions) {\n            const { background, fontColor, fontSize, paddingBlock, paddingInline, width } = defaultOptions.tooltipOptions\n\n            if (background) {\n                this.#scrollmeter.getScrollmeterContainer()?.style.setProperty('--scrollmeter-tooltip-background', background)\n            }\n            if (fontColor) {\n                this.#scrollmeter.getScrollmeterContainer()?.style.setProperty('--scrollmeter-tooltip-font-color', fontColor)\n            }\n            if (fontSize) {\n                this.#scrollmeter.getScrollmeterContainer()?.style.setProperty('--scrollmeter-tooltip-font-size', `${fontSize}px`)\n            }\n            if (paddingBlock) {\n                this.#scrollmeter.getScrollmeterContainer()?.style.setProperty('--scrollmeter-tooltip-padding-block', `${paddingBlock}px`)\n            }\n            if (paddingInline) {\n                this.#scrollmeter.getScrollmeterContainer()?.style.setProperty('--scrollmeter-tooltip-padding-inline', `${paddingInline}px`)\n            }\n            if (width) {\n                this.#scrollmeter.getScrollmeterContainer()?.style.setProperty('--scrollmeter-tooltip-width', `${width}px`)\n            }\n        }\n    }\n}\n","import styles from '../styles/scrollmeter.module.scss'\nimport { IScrollmeter } from '../types/scrollmeter.types'\nimport { Scrollmeter } from './scrollmeter'\nimport { ScrollmeterTooltip } from './scrollmeter-tooltip'\n\nexport class ScrollmeterTimeline extends IScrollmeter {\n    #scrollmeter: Scrollmeter\n\n    constructor(scrollmeter: Scrollmeter) {\n        super()\n        this.#scrollmeter = scrollmeter\n    }\n\n    #findTimelineElements = (element: HTMLElement): HTMLElement[] => {\n        const elArray: HTMLElement[] = []\n\n        const searchH1 = (el: HTMLElement) => {\n            if (el.tagName.toLowerCase() === 'h1') {\n                if (this.#isElementVisible(el)) {\n                    elArray.push(el as HTMLHeadingElement)\n                }\n            }\n\n            Array.from(el.children).forEach((child) => {\n                searchH1(child as HTMLElement)\n            })\n        }\n\n        searchH1(element)\n\n        return elArray\n    }\n\n    #isElementVisible(element: HTMLElement): boolean {\n        // 요소 자체나 부모 요소들의 style 체크\n        const style = window.getComputedStyle(element)\n        if (style.display === 'none') return false\n        if (style.visibility === 'hidden') return false\n        if (style.opacity === '0') return false\n\n        // 부모 요소들도 순차적으로 확인\n        let currentElement: HTMLElement | null = element.parentElement\n        while (currentElement) {\n            const parentStyle = window.getComputedStyle(currentElement)\n            if (parentStyle.display === 'none') return false\n            if (parentStyle.visibility === 'hidden') return false\n            if (parentStyle.opacity === '0') return false\n            currentElement = currentElement.parentElement\n        }\n\n        return true\n    }\n\n    public createTimeline = (highestZIndex: number): ScrollmeterTimeline => {\n        const targetContainer = this.#scrollmeter.getTargetContainer()\n        if (!targetContainer) return null\n\n        const targetElement = this.#findTimelineElements(targetContainer)\n\n        if (targetElement.length === 0) return null\n\n        const timelineElements: HTMLElement[] = []\n        const timelineWidth = this.#scrollmeter.getDefaultOptions().timelineOptions?.width ?? 4\n        let outOfBoundIndex = targetElement.length\n\n        targetElement.map((element) => {\n            const scrollContainer = this.#scrollmeter.getTargetContainer()\n\n            if (!scrollContainer) return\n\n            const timelineElement = document.createElement('div')\n            timelineElement.classList.add(styles.scrollmeter_timeline)\n\n            const absoluteElementTop = element.getBoundingClientRect().top + window.scrollY\n            const absoluteContainerTop = scrollContainer.getBoundingClientRect().top + window.scrollY\n            const relativeTargetTop = absoluteElementTop - absoluteContainerTop\n            const scrollableHeight = scrollContainer.clientHeight - document.documentElement.clientHeight\n\n            timelineElement.style.zIndex = highestZIndex.toString()\n\n            timelineElement.addEventListener('click', () => {\n                element.scrollIntoView({ behavior: 'smooth' })\n            })\n\n            if (scrollableHeight > absoluteElementTop) {\n                const relativePosition = (relativeTargetTop / scrollableHeight) * 100\n\n                timelineElement.style.left = `${relativePosition > 100 ? `calc(100% - ${timelineWidth}px)` : `${relativePosition}%`}`\n\n                if (this.#scrollmeter.getDefaultOptions().useTooltip) {\n                    const tooltip = new ScrollmeterTooltip(this.#scrollmeter)\n\n                    tooltip.createTimelineTooltip(timelineElement, element, relativePosition < 7.6 ? 'left' : 'center')\n                }\n            } else {\n                timelineElement.style.left = `calc(100% - ${timelineWidth * (outOfBoundIndex-- * 4)}px)`\n\n                if (this.#scrollmeter.getDefaultOptions().useTooltip) {\n                    const tooltip = new ScrollmeterTooltip(this.#scrollmeter)\n\n                    tooltip.createTimelineTooltip(timelineElement, element, 'right')\n                }\n            }\n\n            this.#scrollmeter.getScrollmeterContainer()?.appendChild(timelineElement)\n            timelineElements.push(timelineElement)\n        })\n\n        this.setCSSCustomProperties()\n\n        return this\n    }\n\n    public setCSSCustomProperties() {\n        const defaultOptions = this.#scrollmeter.getDefaultOptions()\n        // css custom\n        if (defaultOptions && defaultOptions.timelineOptions) {\n            const { color, width } = defaultOptions.timelineOptions\n\n            if (color) {\n                this.#scrollmeter.getScrollmeterContainer()?.style.setProperty('--scrollmeter-timeline-color', color)\n            }\n            if (width) {\n                this.#scrollmeter.getScrollmeterContainer()?.style.setProperty('--scrollmeter-timeline-width', `${width}px`)\n            }\n        }\n    }\n}\n","import * as htmlToImage from 'html-to-image'\nimport styles from '../styles/scrollmeter.module.scss'\nimport { IScrollmeter, ScrollmeterOptions } from '../types/scrollmeter.types'\nimport { ScrollmeterTimeline } from './scrollmeter-timeline'\n\nexport class Scrollmeter extends IScrollmeter {\n    #defaultOptions: ScrollmeterOptions\n    #targetContainer: HTMLElement | null\n    #scrollmeterContainer: HTMLDivElement | null\n    #scrollmeterBar: HTMLDivElement | null\n    #resizeObserver: ResizeObserver | null\n\n    #timelineElements: ScrollmeterTimeline | null\n\n    #captureCanvas: HTMLCanvasElement | null\n\n    #containerHeight: number\n    #barWidth: number\n    #totalHeight: number\n    #elementTop: number\n    #highestZIndex: number\n\n    #isInView: boolean\n\n    constructor(options: ScrollmeterOptions) {\n        super()\n        const { targetId } = options\n        this.#defaultOptions = options\n\n        this.#targetContainer = document.getElementById(targetId) ?? null\n        this.#scrollmeterContainer = null\n        this.#scrollmeterBar = null\n        this.#resizeObserver = null\n        this.#captureCanvas = null\n        this.#timelineElements = null\n\n        // 숫자 필드 초기화\n        this.#containerHeight = 0\n        this.#barWidth = 0\n        this.#totalHeight = 0\n        this.#elementTop = 0\n        this.#highestZIndex = 0\n\n        this.#isInView = false\n\n        this.#initResizeObserver()\n\n        this.#createScrollmeter()\n    }\n\n    #initResizeObserver = () => {\n        if (!this.#targetContainer) {\n            throw new Error('targetContainer is not found')\n        }\n\n        this.#resizeObserver = new ResizeObserver(async (entries) => {\n            if (!this.#targetContainer) return\n\n            if (!this.#scrollmeterContainer || this.#containerHeight === entries[0].contentRect.height) return\n\n            this.#containerHeight = entries[0].contentRect.height\n\n            const marginTop = parseInt(window.getComputedStyle(this.#targetContainer).marginTop)\n            const marginBottom = parseInt(window.getComputedStyle(this.#targetContainer).marginBottom)\n            this.#elementTop = window.scrollY + this.#targetContainer.getBoundingClientRect().top\n            this.#totalHeight = this.#targetContainer.clientHeight + marginTop + marginBottom - document.documentElement.clientHeight\n\n            this.#updateBarWidth()\n\n            if (this.#defaultOptions.useTimeline) {\n                document.querySelectorAll(`.${styles.scrollmeter_timeline}`).forEach((element) => {\n                    element.remove()\n                })\n\n                if (this.#defaultOptions.usePreview) {\n                    await this.#captureContainer()\n                }\n\n                const timeline = new ScrollmeterTimeline(this)\n\n                this.#timelineElements = timeline.createTimeline(this.#highestZIndex)\n            }\n        })\n    }\n\n    #createScrollmeterContainer = () => {\n        try {\n            if (!this.#targetContainer) throw new Error('targetContainer is not found')\n\n            const scrollmeterContainer = document.createElement('div') as HTMLDivElement\n            scrollmeterContainer.classList.add(styles.scrollmeter_container)\n\n            const highestZIndex = this.#findHighestZIndex(this.#targetContainer)\n            this.#highestZIndex = highestZIndex\n            scrollmeterContainer.style.zIndex = highestZIndex.toString()\n\n            const scrollmeterBar = this.#createScrollmeterBar()\n            scrollmeterContainer.appendChild(scrollmeterBar)\n\n            this.#scrollmeterContainer = scrollmeterContainer\n\n            this.setCSSCustomProperties()\n\n            return scrollmeterContainer\n        } catch (error) {\n            console.error(error)\n        }\n    }\n\n    #createScrollmeterBar = () => {\n        const scrollmeterBar = document.createElement('div')\n        scrollmeterBar.classList.add(styles.scrollmeter_bar)\n\n        this.#scrollmeterBar = scrollmeterBar\n\n        return scrollmeterBar\n    }\n\n    #findHighestZIndex = (element: HTMLElement) => {\n        let highest = 0\n\n        const zIndex = window.getComputedStyle(element).zIndex\n\n        if (zIndex !== 'auto') {\n            highest = Math.max(highest, parseInt(zIndex))\n        }\n\n        Array.from(element.children).forEach((child) => {\n            highest = Math.max(highest, this.#findHighestZIndex(child as HTMLElement))\n        })\n\n        return highest + 1\n    }\n\n    #updateBarWidth = () => {\n        if (!this.#targetContainer) return\n        if (!this.#isInView) return\n\n        const isVisibleScrollmeter = this.#isVisibleScrollmeter()\n\n        if (!isVisibleScrollmeter) {\n            this.#scrollmeterContainer!.style.opacity = '0'\n            return\n        }\n\n        this.#scrollmeterContainer!.style.opacity = '1'\n\n        const currentScroll = window.scrollY - this.#elementTop\n        const scrollPercentage = (currentScroll / this.#totalHeight) * 100\n\n        this.#barWidth = Math.min(100, Math.max(0, scrollPercentage))\n\n        if (this.#scrollmeterBar) {\n            this.#scrollmeterBar.style.width = `${this.#barWidth}%`\n        }\n    }\n\n    #throttle = (func: Function, limit: number) => {\n        let inThrottle: boolean = false\n\n        return () => {\n            if (!inThrottle) {\n                func.apply(this)\n                inThrottle = true\n                setTimeout(() => {\n                    inThrottle = false\n                }, limit)\n            }\n        }\n    }\n\n    #throttledUpdateBarWidth = this.#throttle(this.#updateBarWidth, 16)\n\n    #isVisibleScrollmeter = () => {\n        if (!this.#targetContainer) return false\n\n        return this.#targetContainer.getBoundingClientRect().top <= 0 && this.#targetContainer.getBoundingClientRect().bottom > 0\n    }\n\n    #captureContainer = async () => {\n        if (!this.#targetContainer) return\n\n        try {\n            // 전체 문서 크기 계산\n            const docWidth = Math.max(\n                document.documentElement.scrollWidth,\n                document.documentElement.offsetWidth,\n                document.documentElement.clientWidth\n            )\n            const docHeight = Math.max(\n                document.documentElement.scrollHeight,\n                document.documentElement.offsetHeight,\n                document.documentElement.clientHeight\n            )\n\n            // DOM 업데이트를 위한 대기\n            await new Promise((resolve) => setTimeout(resolve, 100))\n\n            const canvas = await htmlToImage.toCanvas(document.documentElement, {\n                width: docWidth,\n                height: docHeight,\n                filter: (node) => {\n                    return !(node instanceof HTMLElement && node.classList?.contains(styles.scrollmeter_container))\n                },\n                backgroundColor: getComputedStyle(document.body).backgroundColor || '#ffffff',\n            })\n\n            this.#captureCanvas = canvas\n\n            return canvas\n        } catch (error) {\n            console.error('미리보기 생성 중 오류 발생:', error)\n            return null\n        }\n    }\n\n    #createScrollmeter = () => {\n        try {\n            if (!this.#targetContainer) throw new Error('targetContainer is not found')\n\n            const existingScrollmeter = document.querySelectorAll(`.${styles.scrollmeter_container}`)\n\n            if (existingScrollmeter.length > 0) {\n                return null\n            }\n\n            if (!this.#resizeObserver) {\n                throw new Error('resizeObserver is not found')\n            }\n\n            const container = this.#createScrollmeterContainer()\n\n            if (!container) throw new Error('scrollmetercontainer is not found')\n\n            this.#targetContainer.appendChild(container)\n\n            this.#resizeObserver.observe(this.#targetContainer)\n\n            const observer = new IntersectionObserver((entries) => {\n                entries.forEach((entry) => {\n                    if (entry.isIntersecting) {\n                        this.#isInView = true\n                        this.#updateBarWidth()\n                    } else {\n                        this.#isInView = false\n                    }\n                })\n            })\n\n            observer.observe(this.#targetContainer)\n\n            window.addEventListener('scroll', this.#throttledUpdateBarWidth)\n        } catch (error) {\n            console.error(error)\n        }\n    }\n\n    protected setCSSCustomProperties = () => {\n        if (!this.#scrollmeterContainer) return\n        // css custom\n        if (this.#defaultOptions.barOptions) {\n            const { color, background, height } = this.#defaultOptions.barOptions\n            if (color) {\n                this.#scrollmeterContainer.style.setProperty('--scrollmeter-bar-color', color)\n            }\n            if (background) {\n                this.#scrollmeterContainer.style.setProperty('--scrollmeter-bar-background', background)\n            }\n            if (height) {\n                this.#scrollmeterContainer.style.setProperty('--scrollmeter-bar-height', `${height}px`)\n            }\n        }\n    }\n\n    public getTargetContainer = () => {\n        return this.#targetContainer\n    }\n\n    public getScrollmeterContainer = () => {\n        return this.#scrollmeterContainer\n    }\n\n    public getCaptureCanvas = () => {\n        return this.#captureCanvas || null\n    }\n\n    public getDefaultOptions = () => {\n        return this.#defaultOptions\n    }\n\n    public updateScrollmeterStyle = (options: ScrollmeterOptions) => {\n        this.#defaultOptions = options\n\n        this.setCSSCustomProperties()\n\n        this.#timelineElements?.setCSSCustomProperties()\n\n        // css custom\n        if (this.#defaultOptions && this.#defaultOptions.tooltipOptions) {\n            const { background, fontColor, fontSize, paddingBlock, paddingInline, width } = this.#defaultOptions.tooltipOptions\n\n            if (background) {\n                this.#scrollmeterContainer.style.setProperty('--scrollmeter-tooltip-background', background)\n            }\n            if (fontColor) {\n                this.#scrollmeterContainer.style.setProperty('--scrollmeter-tooltip-font-color', fontColor)\n            }\n            if (fontSize) {\n                this.#scrollmeterContainer.style.setProperty('--scrollmeter-tooltip-font-size', `${fontSize}px`)\n            }\n            if (paddingBlock) {\n                this.#scrollmeterContainer.style.setProperty('--scrollmeter-tooltip-padding-block', `${paddingBlock}px`)\n            }\n            if (paddingInline) {\n                this.#scrollmeterContainer.style.setProperty('--scrollmeter-tooltip-padding-inline', `${paddingInline}px`)\n            }\n            if (width) {\n                this.#scrollmeterContainer.style.setProperty('--scrollmeter-tooltip-width', `${width}px`)\n            }\n        }\n    }\n}\n","import { Scrollmeter } from './class/scrollmeter'\nimport { ScrollmeterOptions } from './types/scrollmeter.types'\n\nexport const createScrollmeter = (options: ScrollmeterOptions): Scrollmeter | null => {\n    try {\n        return new Scrollmeter(options)\n    } catch (error) {\n        console.error(error)\n        return null\n    }\n}\n"],"names":["resolveUrl","url","baseUrl","doc","base","a","uuid","counter","random","toArray","arrayLike","arr","l","px","node","styleProperty","val","getNodeWidth","leftBorder","rightBorder","getNodeHeight","topBorder","bottomBorder","getImageSize","targetNode","options","width","height","getPixelRatio","ratio","FINAL_PROCESS","canvasDimensionLimit","checkCanvasDimensions","canvas","createImage","resolve","reject","img","svgToDataURL","svg","html","nodeToDataURL","xmlns","foreignObject","isInstanceOfElement","instance","nodePrototype","formatCSSText","style","content","formatCSSProperties","name","value","priority","getPseudoElementStyle","className","pseudo","selector","cssText","clonePseudoElement","nativeNode","clonedNode","styleElement","clonePseudoElements","WOFF","JPEG","mimes","getExtension","match","getMimeType","extension","getContentFromDataUrl","dataURL","isDataUrl","makeDataUrl","mimeType","fetchAsDataURL","init","process","res","blob","reader","error","cache","getCacheKey","contentType","includeQueryParams","key","resourceToDataURL","resourceUrl","cacheKey","result","msg","cloneCanvasElement","cloneVideoElement","video","ctx","poster","cloneIFrameElement","iframe","_a","cloneNode","cloneSingleNode","isSlotElement","cloneChildren","_b","children","deferred","child","clonedChild","cloneCSSStyle","targetStyle","sourceStyle","cloneInputValue","cloneSelectValue","clonedSelect","selectedOption","decorate","ensureSVGSymbols","clone","uses","processedDefs","i","id","exist","definition","nodes","ns","defs","isRoot","URL_REGEX","URL_WITH_FORMAT_REGEX","FONT_SRC_REGEX","toRegex","escaped","parseURLs","urls","raw","quotation","embed","resourceURL","baseURL","getContentFromUrl","resolvedURL","filterPreferredFontFormat","str","preferredFontFormat","src","format","shouldEmbed","embedResources","filteredCSSText","css","embedProp","propName","propValue","cssString","embedBackground","embedImageNode","isImageElement","image","embedChildren","deferreds","embedImages","applyStyle","manual","cssFetchCache","fetchCSS","embedFonts","data","regexUrl","loadFonts","loc","parseCSS","source","commentsRegex","keyframesRegex","matches","importRegex","combinedCSSRegex","unifiedRegex","getCSSRules","styleSheets","ret","sheet","item","index","importIndex","metadata","rule","e","inline","err","getWebFontRules","cssRules","parseWebFontRules","getWebFontCSS","rules","embedWebFonts","styleNode","sytleContent","toSvg","toCanvas","context","canvasWidth","canvasHeight","IScrollmeter","_scrollmeter","_cropImageAtPercent","_createPreview","ScrollmeterTooltip","scrollmeter","__privateAdd","__privateSet","targetElement","cropWidth","captureCanvas","__privateGet","y","cropHeight","tempCanvas","dataUrl","div","styles","timelineElement","direction","timelineTooltip","timelineTooltipText","preview","_c","_d","_e","_f","defaultOptions","background","fontColor","fontSize","paddingBlock","paddingInline","_findTimelineElements","_ScrollmeterTimeline_instances","isElementVisible_fn","ScrollmeterTimeline","element","elArray","searchH1","el","__privateMethod","highestZIndex","targetContainer","timelineWidth","outOfBoundIndex","scrollContainer","absoluteElementTop","absoluteContainerTop","relativeTargetTop","scrollableHeight","relativePosition","color","currentElement","parentStyle","_defaultOptions","_targetContainer","_scrollmeterContainer","_scrollmeterBar","_resizeObserver","_timelineElements","_captureCanvas","_containerHeight","_barWidth","_totalHeight","_elementTop","_highestZIndex","_isInView","_initResizeObserver","_createScrollmeterContainer","_createScrollmeterBar","_findHighestZIndex","_updateBarWidth","_throttle","_throttledUpdateBarWidth","_isVisibleScrollmeter","_captureContainer","_createScrollmeter","Scrollmeter","entries","marginTop","marginBottom","timeline","scrollmeterContainer","scrollmeterBar","highest","zIndex","scrollPercentage","func","limit","inThrottle","docWidth","docHeight","htmlToImage.toCanvas","container","entry","targetId","createScrollmeter"],"mappings":";;;;;AAAO,SAASA,GAAWC,GAAKC,GAAS;AAErC,MAAID,EAAI,MAAM,eAAe;AACzB,WAAOA;AAGX,MAAIA,EAAI,MAAM,OAAO;AACjB,WAAO,OAAO,SAAS,WAAWA;AAGtC,MAAIA,EAAI,MAAM,WAAW;AACrB,WAAOA;AAEX,QAAME,IAAM,SAAS,eAAe,mBAAoB,GAClDC,IAAOD,EAAI,cAAc,MAAM,GAC/BE,IAAIF,EAAI,cAAc,GAAG;AAC/B,SAAAA,EAAI,KAAK,YAAYC,CAAI,GACzBD,EAAI,KAAK,YAAYE,CAAC,GAClBH,MACAE,EAAK,OAAOF,IAEhBG,EAAE,OAAOJ,GACFI,EAAE;AACb;AACO,MAAMC,KAAQ,uBAAM;AAGvB,MAAIC,IAAU;AAEd,QAAMC,IAAS;AAAA;AAAA,IAEf,QAAS,KAAK,OAAM,IAAK,MAAM,KAAM,GAAG,SAAS,EAAE,CAAC,GAAG,MAAM,EAAE;AAAA;AAC/D,SAAO,OACHD,KAAW,GACJ,IAAIC,GAAQ,GAAGD,CAAO;AAErC,GAAI;AAMG,SAASE,EAAQC,GAAW;AAC/B,QAAMC,IAAM,CAAE;AACd,WAAS,IAAI,GAAGC,IAAIF,EAAU,QAAQ,IAAIE,GAAG;AACzC,IAAAD,EAAI,KAAKD,EAAU,CAAC,CAAC;AAEzB,SAAOC;AACX;AACA,SAASE,EAAGC,GAAMC,GAAe;AAE7B,QAAMC,KADMF,EAAK,cAAc,eAAe,QAC9B,iBAAiBA,CAAI,EAAE,iBAAiBC,CAAa;AACrE,SAAOC,IAAM,WAAWA,EAAI,QAAQ,MAAM,EAAE,CAAC,IAAI;AACrD;AACA,SAASC,GAAaH,GAAM;AACxB,QAAMI,IAAaL,EAAGC,GAAM,mBAAmB,GACzCK,IAAcN,EAAGC,GAAM,oBAAoB;AACjD,SAAOA,EAAK,cAAcI,IAAaC;AAC3C;AACA,SAASC,GAAcN,GAAM;AACzB,QAAMO,IAAYR,EAAGC,GAAM,kBAAkB,GACvCQ,IAAeT,EAAGC,GAAM,qBAAqB;AACnD,SAAOA,EAAK,eAAeO,IAAYC;AAC3C;AACO,SAASC,GAAaC,GAAYC,IAAU,IAAI;AACnD,QAAMC,IAAQD,EAAQ,SAASR,GAAaO,CAAU,GAChDG,IAASF,EAAQ,UAAUL,GAAcI,CAAU;AACzD,SAAO,EAAE,OAAAE,GAAO,QAAAC,EAAQ;AAC5B;AACO,SAASC,KAAgB;AAC5B,MAAIC,GACAC;AACJ,MAAI;AACA,IAAAA,IAAgB;AAAA,EACxB,QACc;AAAA,EAEd;AACI,QAAMd,IAAMc,KAAiBA,EAAc,MACrCA,EAAc,IAAI,mBAClB;AACN,SAAId,MACAa,IAAQ,SAASb,GAAK,EAAE,GACpB,OAAO,MAAMa,CAAK,MAClBA,IAAQ,KAGTA,KAAS,OAAO,oBAAoB;AAC/C;AAEA,MAAME,IAAuB;AACtB,SAASC,GAAsBC,GAAQ;AAC1C,GAAIA,EAAO,QAAQF,KACfE,EAAO,SAASF,OACZE,EAAO,QAAQF,KACfE,EAAO,SAASF,IACZE,EAAO,QAAQA,EAAO,UACtBA,EAAO,UAAUF,IAAuBE,EAAO,OAC/CA,EAAO,QAAQF,MAGfE,EAAO,SAASF,IAAuBE,EAAO,QAC9CA,EAAO,SAASF,KAGfE,EAAO,QAAQF,KACpBE,EAAO,UAAUF,IAAuBE,EAAO,OAC/CA,EAAO,QAAQF,MAGfE,EAAO,SAASF,IAAuBE,EAAO,QAC9CA,EAAO,SAASF;AAG5B;AAqBO,SAASG,EAAYjC,GAAK;AAC7B,SAAO,IAAI,QAAQ,CAACkC,GAASC,MAAW;AACpC,UAAMC,IAAM,IAAI,MAAO;AACvB,IAAAA,EAAI,SAAS,MAAMF,EAAQE,CAAG,GAC9BA,EAAI,SAAS,MAAMF,EAAQE,CAAG,GAC9BA,EAAI,UAAUD,GACdC,EAAI,cAAc,aAClBA,EAAI,WAAW,SACfA,EAAI,MAAMpC;AAAA,EAClB,CAAK;AACL;AACO,eAAeqC,GAAaC,GAAK;AACpC,SAAO,QAAQ,QAAO,EACjB,KAAK,MAAM,IAAI,gBAAgB,kBAAkBA,CAAG,CAAC,EACrD,KAAK,kBAAkB,EACvB,KAAK,CAACC,MAAS,oCAAoCA,CAAI,EAAE;AAClE;AACO,eAAeC,GAAc3B,GAAMY,GAAOC,GAAQ;AACrD,QAAMe,IAAQ,8BACRH,IAAM,SAAS,gBAAgBG,GAAO,KAAK,GAC3CC,IAAgB,SAAS,gBAAgBD,GAAO,eAAe;AACrE,SAAAH,EAAI,aAAa,SAAS,GAAGb,CAAK,EAAE,GACpCa,EAAI,aAAa,UAAU,GAAGZ,CAAM,EAAE,GACtCY,EAAI,aAAa,WAAW,OAAOb,CAAK,IAAIC,CAAM,EAAE,GACpDgB,EAAc,aAAa,SAAS,MAAM,GAC1CA,EAAc,aAAa,UAAU,MAAM,GAC3CA,EAAc,aAAa,KAAK,GAAG,GACnCA,EAAc,aAAa,KAAK,GAAG,GACnCA,EAAc,aAAa,6BAA6B,MAAM,GAC9DJ,EAAI,YAAYI,CAAa,GAC7BA,EAAc,YAAY7B,CAAI,GACvBwB,GAAaC,CAAG;AAC3B;AACO,MAAMK,IAAsB,CAAC9B,GAAM+B,MAAa;AACnD,MAAI/B,aAAgB+B;AAChB,WAAO;AACX,QAAMC,IAAgB,OAAO,eAAehC,CAAI;AAChD,SAAIgC,MAAkB,OACX,KACHA,EAAc,YAAY,SAASD,EAAS,QAChDD,EAAoBE,GAAeD,CAAQ;AACnD;AC/KA,SAASE,GAAcC,GAAO;AAC1B,QAAMC,IAAUD,EAAM,iBAAiB,SAAS;AAChD,SAAO,GAAGA,EAAM,OAAO,cAAcC,EAAQ,QAAQ,QAAQ,EAAE,CAAC;AACpE;AACA,SAASC,GAAoBF,GAAO;AAChC,SAAOvC,EAAQuC,CAAK,EACf,IAAI,CAACG,MAAS;AACf,UAAMC,IAAQJ,EAAM,iBAAiBG,CAAI,GACnCE,IAAWL,EAAM,oBAAoBG,CAAI;AAC/C,WAAO,GAAGA,CAAI,KAAKC,CAAK,GAAGC,IAAW,gBAAgB,EAAE;AAAA,EAC3D,CAAA,EACI,KAAK,GAAG;AACjB;AACA,SAASC,GAAsBC,GAAWC,GAAQR,GAAO;AACrD,QAAMS,IAAW,IAAIF,CAAS,IAAIC,CAAM,IAClCE,IAAUV,EAAM,UAChBD,GAAcC,CAAK,IACnBE,GAAoBF,CAAK;AAC/B,SAAO,SAAS,eAAe,GAAGS,CAAQ,IAAIC,CAAO,GAAG;AAC5D;AACA,SAASC,GAAmBC,GAAYC,GAAYL,GAAQ;AACxD,QAAMR,IAAQ,OAAO,iBAAiBY,GAAYJ,CAAM,GAClDP,IAAUD,EAAM,iBAAiB,SAAS;AAChD,MAAIC,MAAY,MAAMA,MAAY;AAC9B;AAEJ,QAAMM,IAAYjD,GAAM;AACxB,MAAI;AACA,IAAAuD,EAAW,YAAY,GAAGA,EAAW,SAAS,IAAIN,CAAS;AAAA,EACnE,QACgB;AACR;AAAA,EACR;AACI,QAAMO,IAAe,SAAS,cAAc,OAAO;AACnD,EAAAA,EAAa,YAAYR,GAAsBC,GAAWC,GAAQR,CAAK,CAAC,GACxEa,EAAW,YAAYC,CAAY;AACvC;AACO,SAASC,GAAoBH,GAAYC,GAAY;AACxD,EAAAF,GAAmBC,GAAYC,GAAY,SAAS,GACpDF,GAAmBC,GAAYC,GAAY,QAAQ;AACvD;ACzCA,MAAMG,KAAO,yBACPC,KAAO,cACPC,KAAQ;AAAA,EACV,MAAMF;AAAA,EACN,OAAOA;AAAA,EACP,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAKC;AAAA,EACL,MAAMA;AAAA,EACN,KAAK;AAAA,EACL,MAAM;AAAA,EACN,KAAK;AAAA,EACL,MAAM;AACV;AACA,SAASE,GAAalE,GAAK;AACvB,QAAMmE,IAAQ,gBAAgB,KAAKnE,CAAG;AACtC,SAAOmE,IAAQA,EAAM,CAAC,IAAI;AAC9B;AACO,SAASC,GAAYpE,GAAK;AAC7B,QAAMqE,IAAYH,GAAalE,CAAG,EAAE,YAAa;AACjD,SAAOiE,GAAMI,CAAS,KAAK;AAC/B;ACtBA,SAASC,GAAsBC,GAAS;AACpC,SAAOA,EAAQ,MAAM,GAAG,EAAE,CAAC;AAC/B;AACO,SAASC,GAAUxE,GAAK;AAC3B,SAAOA,EAAI,OAAO,UAAU,MAAM;AACtC;AACO,SAASyE,GAAYzB,GAAS0B,GAAU;AAC3C,SAAO,QAAQA,CAAQ,WAAW1B,CAAO;AAC7C;AACO,eAAe2B,GAAe3E,GAAK4E,GAAMC,GAAS;AACrD,QAAMC,IAAM,MAAM,MAAM9E,GAAK4E,CAAI;AACjC,MAAIE,EAAI,WAAW;AACf,UAAM,IAAI,MAAM,aAAaA,EAAI,GAAG,aAAa;AAErD,QAAMC,IAAO,MAAMD,EAAI,KAAM;AAC7B,SAAO,IAAI,QAAQ,CAAC5C,GAASC,MAAW;AACpC,UAAM6C,IAAS,IAAI,WAAY;AAC/B,IAAAA,EAAO,UAAU7C,GACjB6C,EAAO,YAAY,MAAM;AACrB,UAAI;AACA,QAAA9C,EAAQ2C,EAAQ,EAAE,KAAAC,GAAK,QAAQE,EAAO,OAAM,CAAE,CAAC;AAAA,MAC/D,SACmBC,GAAO;AACV,QAAA9C,EAAO8C,CAAK;AAAA,MAC5B;AAAA,IACS,GACDD,EAAO,cAAcD,CAAI;AAAA,EACjC,CAAK;AACL;AACA,MAAMG,KAAQ,CAAE;AAChB,SAASC,GAAYnF,GAAKoF,GAAaC,GAAoB;AACvD,MAAIC,IAAMtF,EAAI,QAAQ,QAAQ,EAAE;AAChC,SAAIqF,MACAC,IAAMtF,IAGN,sBAAsB,KAAKsF,CAAG,MAC9BA,IAAMA,EAAI,QAAQ,QAAQ,EAAE,IAEzBF,IAAc,IAAIA,CAAW,IAAIE,CAAG,KAAKA;AACpD;AACO,eAAeC,GAAkBC,GAAaJ,GAAa5D,GAAS;AACvE,QAAMiE,IAAWN,GAAYK,GAAaJ,GAAa5D,EAAQ,kBAAkB;AACjF,MAAI0D,GAAMO,CAAQ,KAAK;AACnB,WAAOP,GAAMO,CAAQ;AAGzB,EAAIjE,EAAQ,cAERgE,MAAgB,KAAK,KAAKA,CAAW,IAAI,MAAM,QAAO,oBAAI,KAAM,GAAC,QAAS;AAE9E,MAAIjB;AACJ,MAAI;AACA,UAAMvB,IAAU,MAAM2B,GAAea,GAAahE,EAAQ,kBAAkB,CAAC,EAAE,KAAAsD,GAAK,QAAAY,SAC3EN,MAEDA,IAAcN,EAAI,QAAQ,IAAI,cAAc,KAAK,KAE9CR,GAAsBoB,CAAM,EACtC;AACD,IAAAnB,IAAUE,GAAYzB,GAASoC,CAAW;AAAA,EAClD,SACWH,GAAO;AACV,IAAAV,IAAU/C,EAAQ,oBAAoB;AACtC,QAAImE,IAAM,6BAA6BH,CAAW;AAClD,IAAIP,MACAU,IAAM,OAAOV,KAAU,WAAWA,IAAQA,EAAM,UAEhDU,KACA,QAAQ,KAAKA,CAAG;AAAA,EAE5B;AACI,SAAAT,GAAMO,CAAQ,IAAIlB,GACXA;AACX;ACtEA,eAAeqB,GAAmB5D,GAAQ;AACtC,QAAMuC,IAAUvC,EAAO,UAAW;AAClC,SAAIuC,MAAY,WACLvC,EAAO,UAAU,EAAK,IAE1BC,EAAYsC,CAAO;AAC9B;AACA,eAAesB,GAAkBC,GAAOtE,GAAS;AAC7C,MAAIsE,EAAM,YAAY;AAClB,UAAM9D,IAAS,SAAS,cAAc,QAAQ,GACxC+D,IAAM/D,EAAO,WAAW,IAAI;AAClC,IAAAA,EAAO,QAAQ8D,EAAM,aACrB9D,EAAO,SAAS8D,EAAM,cACtBC,KAAQ,QAAkCA,EAAI,UAAUD,GAAO,GAAG,GAAG9D,EAAO,OAAOA,EAAO,MAAM;AAChG,UAAMuC,IAAUvC,EAAO,UAAW;AAClC,WAAOC,EAAYsC,CAAO;AAAA,EAClC;AACI,QAAMyB,IAASF,EAAM,QACfV,IAAchB,GAAY4B,CAAM,GAChCzB,IAAU,MAAMgB,GAAkBS,GAAQZ,GAAa5D,CAAO;AACpE,SAAOS,EAAYsC,CAAO;AAC9B;AACA,eAAe0B,GAAmBC,GAAQ;AACtC,MAAIC;AACJ,MAAI;AACA,QAAK,GAAAA,IAAKD,KAAW,OAA4B,SAASA,EAAO,qBAAqB,QAAQC,MAAO,WAAkBA,EAAG;AACtH,aAAQ,MAAMC,GAAUF,EAAO,gBAAgB,MAAM,CAAE,GAAE,EAAI;AAAA,EAEzE,QACe;AAAA,EAEf;AACI,SAAOA,EAAO,UAAU,EAAK;AACjC;AACA,eAAeG,GAAgBxF,GAAMW,GAAS;AAC1C,SAAImB,EAAoB9B,GAAM,iBAAiB,IACpC+E,GAAmB/E,CAAI,IAE9B8B,EAAoB9B,GAAM,gBAAgB,IACnCgF,GAAkBhF,GAAMW,CAAO,IAEtCmB,EAAoB9B,GAAM,iBAAiB,IACpCoF,GAAmBpF,CAAI,IAE3BA,EAAK,UAAU,EAAK;AAC/B;AACA,MAAMyF,KAAgB,CAACzF,MAASA,EAAK,WAAW,QAAQA,EAAK,QAAQ,YAAW,MAAO;AACvF,eAAe0F,GAAc5C,GAAYC,GAAYpC,GAAS;AAC1D,MAAI2E,GAAIK;AACR,MAAIC,IAAW,CAAE;AAWjB,SAVIH,GAAc3C,CAAU,KAAKA,EAAW,gBACxC8C,IAAWjG,EAAQmD,EAAW,eAAe,IAExChB,EAAoBgB,GAAY,iBAAiB,MACpD,GAAAwC,IAAKxC,EAAW,qBAAqB,QAAQwC,MAAO,WAAkBA,EAAG,QAC3EM,IAAWjG,EAAQmD,EAAW,gBAAgB,KAAK,UAAU,IAG7D8C,IAAWjG,IAAUgG,IAAK7C,EAAW,gBAAgB,QAAQ6C,MAAO,SAASA,IAAK7C,GAAY,UAAU,GAExG8C,EAAS,WAAW,KACpB9D,EAAoBgB,GAAY,gBAAgB,KAGpD,MAAM8C,EAAS,OAAO,CAACC,GAAUC,MAAUD,EACtC,KAAK,MAAMN,GAAUO,GAAOnF,CAAO,CAAC,EACpC,KAAK,CAACoF,MAAgB;AACvB,IAAIA,KACAhD,EAAW,YAAYgD,CAAW;AAAA,EAE9C,CAAK,GAAG,QAAQ,SAAS,GACdhD;AACX;AACA,SAASiD,GAAclD,GAAYC,GAAY;AAC3C,QAAMkD,IAAclD,EAAW;AAC/B,MAAI,CAACkD;AACD;AAEJ,QAAMC,IAAc,OAAO,iBAAiBpD,CAAU;AACtD,EAAIoD,EAAY,WACZD,EAAY,UAAUC,EAAY,SAClCD,EAAY,kBAAkBC,EAAY,mBAG1CvG,EAAQuG,CAAW,EAAE,QAAQ,CAAC7D,MAAS;AACnC,QAAIC,IAAQ4D,EAAY,iBAAiB7D,CAAI;AAC7C,IAAIA,MAAS,eAAeC,EAAM,SAAS,IAAI,MAE3CA,IAAQ,GADY,KAAK,MAAM,WAAWA,EAAM,UAAU,GAAGA,EAAM,SAAS,CAAC,CAAC,CAAC,IAAI,GAC7D,OAEtBR,EAAoBgB,GAAY,iBAAiB,KACjDT,MAAS,aACTC,MAAU,aACVA,IAAQ,UAERD,MAAS,OAAOU,EAAW,aAAa,GAAG,MAC3CT,IAAQ,QAAQS,EAAW,aAAa,GAAG,CAAC,MAEhDkD,EAAY,YAAY5D,GAAMC,GAAO4D,EAAY,oBAAoB7D,CAAI,CAAC;AAAA,EACtF,CAAS;AAET;AACA,SAAS8D,GAAgBrD,GAAYC,GAAY;AAC7C,EAAIjB,EAAoBgB,GAAY,mBAAmB,MACnDC,EAAW,YAAYD,EAAW,QAElChB,EAAoBgB,GAAY,gBAAgB,KAChDC,EAAW,aAAa,SAASD,EAAW,KAAK;AAEzD;AACA,SAASsD,GAAiBtD,GAAYC,GAAY;AAC9C,MAAIjB,EAAoBgB,GAAY,iBAAiB,GAAG;AACpD,UAAMuD,IAAetD,GACfuD,IAAiB,MAAM,KAAKD,EAAa,QAAQ,EAAE,KAAK,CAACP,MAAUhD,EAAW,UAAUgD,EAAM,aAAa,OAAO,CAAC;AACzH,IAAIQ,KACAA,EAAe,aAAa,YAAY,EAAE;AAAA,EAEtD;AACA;AACA,SAASC,GAASzD,GAAYC,GAAY;AACtC,SAAIjB,EAAoBiB,GAAY,OAAO,MACvCiD,GAAclD,GAAYC,CAAU,GACpCE,GAAoBH,GAAYC,CAAU,GAC1CoD,GAAgBrD,GAAYC,CAAU,GACtCqD,GAAiBtD,GAAYC,CAAU,IAEpCA;AACX;AACA,eAAeyD,GAAiBC,GAAO9F,GAAS;AAC5C,QAAM+F,IAAOD,EAAM,mBAAmBA,EAAM,iBAAiB,KAAK,IAAI,CAAE;AACxE,MAAIC,EAAK,WAAW;AAChB,WAAOD;AAEX,QAAME,IAAgB,CAAE;AACxB,WAASC,IAAI,GAAGA,IAAIF,EAAK,QAAQE,KAAK;AAElC,UAAMC,IADMH,EAAKE,CAAC,EACH,aAAa,YAAY;AACxC,QAAIC,GAAI;AACJ,YAAMC,IAAQL,EAAM,cAAcI,CAAE,GAC9BE,IAAa,SAAS,cAAcF,CAAE;AAC5C,MAAI,CAACC,KAASC,KAAc,CAACJ,EAAcE,CAAE,MAEzCF,EAAcE,CAAE,IAAK,MAAMtB,GAAUwB,GAAYpG,GAAS,EAAI;AAAA,IAE9E;AAAA,EACA;AACI,QAAMqG,IAAQ,OAAO,OAAOL,CAAa;AACzC,MAAIK,EAAM,QAAQ;AACd,UAAMC,IAAK,gCACLxF,IAAM,SAAS,gBAAgBwF,GAAI,KAAK;AAC9C,IAAAxF,EAAI,aAAa,SAASwF,CAAE,GAC5BxF,EAAI,MAAM,WAAW,YACrBA,EAAI,MAAM,QAAQ,KAClBA,EAAI,MAAM,SAAS,KACnBA,EAAI,MAAM,WAAW,UACrBA,EAAI,MAAM,UAAU;AACpB,UAAMyF,IAAO,SAAS,gBAAgBD,GAAI,MAAM;AAChD,IAAAxF,EAAI,YAAYyF,CAAI;AACpB,aAASN,IAAI,GAAGA,IAAII,EAAM,QAAQJ;AAC9B,MAAAM,EAAK,YAAYF,EAAMJ,CAAC,CAAC;AAE7B,IAAAH,EAAM,YAAYhF,CAAG;AAAA,EAC7B;AACI,SAAOgF;AACX;AACO,eAAelB,GAAUvF,GAAMW,GAASwG,GAAQ;AACnD,SAAI,CAACA,KAAUxG,EAAQ,UAAU,CAACA,EAAQ,OAAOX,CAAI,IAC1C,OAEJ,QAAQ,QAAQA,CAAI,EACtB,KAAK,CAAC+C,MAAeyC,GAAgBzC,GAAYpC,CAAO,CAAC,EACzD,KAAK,CAACoC,MAAe2C,GAAc1F,GAAM+C,GAAYpC,CAAO,CAAC,EAC7D,KAAK,CAACoC,MAAewD,GAASvG,GAAM+C,CAAU,CAAC,EAC/C,KAAK,CAACA,MAAeyD,GAAiBzD,GAAYpC,CAAO,CAAC;AACnE;AC/KA,MAAMyG,KAAY,8BACZC,KAAwB,+CACxBC,KAAiB;AACvB,SAASC,GAAQpI,GAAK;AAElB,QAAMqI,IAAUrI,EAAI,QAAQ,4BAA4B,MAAM;AAC9D,SAAO,IAAI,OAAO,iBAAiBqI,CAAO,eAAe,GAAG;AAChE;AACO,SAASC,GAAU7E,GAAS;AAC/B,QAAM8E,IAAO,CAAE;AACf,SAAA9E,EAAQ,QAAQwE,IAAW,CAACO,GAAKC,GAAWzI,OACxCuI,EAAK,KAAKvI,CAAG,GACNwI,EACV,GACMD,EAAK,OAAO,CAACvI,MAAQ,CAACwE,GAAUxE,CAAG,CAAC;AAC/C;AACO,eAAe0I,GAAMjF,GAASkF,GAAaC,GAASpH,GAASqH,GAAmB;AACnF,MAAI;AACA,UAAMC,IAAcF,IAAU7I,GAAW4I,GAAaC,CAAO,IAAID,GAC3DvD,IAAchB,GAAYuE,CAAW;AAC3C,QAAIpE;AACJ,WAAIsE,MAKAtE,IAAU,MAAMgB,GAAkBuD,GAAa1D,GAAa5D,CAAO,IAEhEiC,EAAQ,QAAQ2E,GAAQO,CAAW,GAAG,KAAKpE,CAAO,IAAI;AAAA,EACrE,QACkB;AAAA,EAElB;AACI,SAAOd;AACX;AACA,SAASsF,GAA0BC,GAAK,EAAE,qBAAAC,KAAuB;AAC7D,SAAQA,IAEFD,EAAI,QAAQb,IAAgB,CAAChE,MAAU;AAErC,eAAa;AACT,YAAM,CAAC+E,GAAG,EAAIC,CAAM,IAAIjB,GAAsB,KAAK/D,CAAK,KAAK,CAAE;AAC/D,UAAI,CAACgF;AACD,eAAO;AAEX,UAAIA,MAAWF;AACX,eAAO,QAAQC,CAAG;AAAA,IAEtC;AAAA,EACA,CAAS,IAZCF;AAaV;AACO,SAASI,GAAYpJ,GAAK;AAC7B,SAAOA,EAAI,OAAOiI,EAAS,MAAM;AACrC;AACO,eAAeoB,GAAe5F,GAASxD,GAASuB,GAAS;AAC5D,MAAI,CAAC4H,GAAY3F,CAAO;AACpB,WAAOA;AAEX,QAAM6F,IAAkBP,GAA0BtF,GAASjC,CAAO;AAElE,SADa8G,GAAUgB,CAAe,EAC1B,OAAO,CAAC5C,GAAU1G,MAAQ0G,EAAS,KAAK,CAAC6C,MAAQb,GAAMa,GAAKvJ,GAAKC,GAASuB,CAAO,CAAC,GAAG,QAAQ,QAAQ8H,CAAe,CAAC;AACrI;AC5DA,eAAeE,EAAUC,GAAU5I,GAAMW,GAAS;AAC9C,MAAI2E;AACJ,QAAMuD,KAAavD,IAAKtF,EAAK,WAAW,QAAQsF,MAAO,SAAS,SAASA,EAAG,iBAAiBsD,CAAQ;AACrG,MAAIC,GAAW;AACX,UAAMC,IAAY,MAAMN,GAAeK,GAAW,MAAMlI,CAAO;AAC/D,WAAAX,EAAK,MAAM,YAAY4I,GAAUE,GAAW9I,EAAK,MAAM,oBAAoB4I,CAAQ,CAAC,GAC7E;AAAA,EACf;AACI,SAAO;AACX;AACA,eAAeG,GAAgBhG,GAAYpC,GAAS;AAChD,EAAM,MAAMgI,EAAU,cAAc5F,GAAYpC,CAAO,KACnD,MAAMgI,EAAU,oBAAoB5F,GAAYpC,CAAO,GAErD,MAAMgI,EAAU,QAAQ5F,GAAYpC,CAAO,KAC7C,MAAMgI,EAAU,cAAc5F,GAAYpC,CAAO;AAEzD;AACA,eAAeqI,GAAejG,GAAYpC,GAAS;AAC/C,QAAMsI,IAAiBnH,EAAoBiB,GAAY,gBAAgB;AACvE,MAAI,EAAEkG,KAAkB,CAACtF,GAAUZ,EAAW,GAAG,MAC7C,EAAEjB,EAAoBiB,GAAY,eAAe,KAC7C,CAACY,GAAUZ,EAAW,KAAK,OAAO;AACtC;AAEJ,QAAM5D,IAAM8J,IAAiBlG,EAAW,MAAMA,EAAW,KAAK,SACxDW,IAAU,MAAMgB,GAAkBvF,GAAKoE,GAAYpE,CAAG,GAAGwB,CAAO;AACtE,QAAM,IAAI,QAAQ,CAACU,GAASC,MAAW;AACnC,IAAAyB,EAAW,SAAS1B,GACpB0B,EAAW,UAAUzB;AACrB,UAAM4H,IAAQnG;AACd,IAAImG,EAAM,WACNA,EAAM,SAAS7H,IAEf6H,EAAM,YAAY,WAClBA,EAAM,UAAU,UAEhBD,KACAlG,EAAW,SAAS,IACpBA,EAAW,MAAMW,KAGjBX,EAAW,KAAK,UAAUW;AAAA,EAEtC,CAAK;AACL;AACA,eAAeyF,GAAcpG,GAAYpC,GAAS;AAE9C,QAAMyI,IADWzJ,EAAQoD,EAAW,UAAU,EACnB,IAAI,CAAC+C,MAAUuD,GAAYvD,GAAOnF,CAAO,CAAC;AACrE,QAAM,QAAQ,IAAIyI,CAAS,EAAE,KAAK,MAAMrG,CAAU;AACtD;AACO,eAAesG,GAAYtG,GAAYpC,GAAS;AACnD,EAAImB,EAAoBiB,GAAY,OAAO,MACvC,MAAMgG,GAAgBhG,GAAYpC,CAAO,GACzC,MAAMqI,GAAejG,GAAYpC,CAAO,GACxC,MAAMwI,GAAcpG,GAAYpC,CAAO;AAE/C;AC7DO,SAAS2I,GAAWtJ,GAAMW,GAAS;AACtC,QAAM,EAAE,OAAAuB,EAAK,IAAKlC;AAClB,EAAIW,EAAQ,oBACRuB,EAAM,kBAAkBvB,EAAQ,kBAEhCA,EAAQ,UACRuB,EAAM,QAAQ,GAAGvB,EAAQ,KAAK,OAE9BA,EAAQ,WACRuB,EAAM,SAAS,GAAGvB,EAAQ,MAAM;AAEpC,QAAM4I,IAAS5I,EAAQ;AACvB,SAAI4I,KAAU,QACV,OAAO,KAAKA,CAAM,EAAE,QAAQ,CAAC9E,MAAQ;AACjC,IAAAvC,EAAMuC,CAAG,IAAI8E,EAAO9E,CAAG;AAAA,EACnC,CAAS,GAEEzE;AACX;ACfA,MAAMwJ,KAAgB,CAAE;AACxB,eAAeC,GAAStK,GAAK;AACzB,MAAIkF,IAAQmF,GAAcrK,CAAG;AAC7B,MAAIkF,KAAS;AACT,WAAOA;AAGX,QAAMzB,IAAU,OADJ,MAAM,MAAMzD,CAAG,GACD,KAAM;AAChC,SAAAkF,IAAQ,EAAE,KAAAlF,GAAK,SAAAyD,EAAS,GACxB4G,GAAcrK,CAAG,IAAIkF,GACdA;AACX;AACA,eAAeqF,GAAWC,GAAMhJ,GAAS;AACrC,MAAIiC,IAAU+G,EAAK;AACnB,QAAMC,IAAW,+BAEXC,KADWjH,EAAQ,MAAM,eAAe,KAAK,CAAE,GAC1B,IAAI,OAAOkH,MAAQ;AAC1C,QAAI3K,IAAM2K,EAAI,QAAQF,GAAU,IAAI;AACpC,WAAKzK,EAAI,WAAW,UAAU,MAC1BA,IAAM,IAAI,IAAIA,GAAKwK,EAAK,GAAG,EAAE,OAE1B7F,GAAe3E,GAAKwB,EAAQ,kBAAkB,CAAC,EAAE,QAAAkE,SACpDjC,IAAUA,EAAQ,QAAQkH,GAAK,OAAOjF,CAAM,GAAG,GACxC,CAACiF,GAAKjF,CAAM,EACtB;AAAA,EACT,CAAK;AACD,SAAO,QAAQ,IAAIgF,CAAS,EAAE,KAAK,MAAMjH,CAAO;AACpD;AACA,SAASmH,GAASC,GAAQ;AACtB,MAAIA,KAAU;AACV,WAAO,CAAE;AAEb,QAAMnF,IAAS,CAAE,GACXoF,IAAgB;AAEtB,MAAIrH,IAAUoH,EAAO,QAAQC,GAAe,EAAE;AAE9C,QAAMC,IAAiB,IAAI,OAAO,oDAAoD,IAAI;AAE1F,aAAa;AACT,UAAMC,IAAUD,EAAe,KAAKtH,CAAO;AAC3C,QAAIuH,MAAY;AACZ;AAEJ,IAAAtF,EAAO,KAAKsF,EAAQ,CAAC,CAAC;AAAA,EAC9B;AACI,EAAAvH,IAAUA,EAAQ,QAAQsH,GAAgB,EAAE;AAC5C,QAAME,IAAc,0CAEdC,IAAmB,8GAGnBC,IAAe,IAAI,OAAOD,GAAkB,IAAI;AAEtD,aAAa;AACT,QAAIF,IAAUC,EAAY,KAAKxH,CAAO;AACtC,QAAIuH,MAAY,MAAM;AAElB,UADAA,IAAUG,EAAa,KAAK1H,CAAO,GAC/BuH,MAAY;AACZ;AAGA,MAAAC,EAAY,YAAYE,EAAa;AAAA,IAErD;AAEY,MAAAA,EAAa,YAAYF,EAAY;AAEzC,IAAAvF,EAAO,KAAKsF,EAAQ,CAAC,CAAC;AAAA,EAC9B;AACI,SAAOtF;AACX;AACA,eAAe0F,GAAYC,GAAa7J,GAAS;AAC7C,QAAM8J,IAAM,CAAE,GACRrB,IAAY,CAAE;AAEpB,SAAAoB,EAAY,QAAQ,CAACE,MAAU;AAC3B,QAAI,cAAcA;AACd,UAAI;AACA,QAAA/K,EAAQ+K,EAAM,YAAY,CAAA,CAAE,EAAE,QAAQ,CAACC,GAAMC,MAAU;AACnD,cAAID,EAAK,SAAS,QAAQ,aAAa;AACnC,gBAAIE,IAAcD,IAAQ;AAC1B,kBAAMzL,IAAMwL,EAAK,MACX9E,IAAW4D,GAAStK,CAAG,EACxB,KAAK,CAAC2L,MAAapB,GAAWoB,GAAUnK,CAAO,CAAC,EAChD,KAAK,CAACiC,MAAYmH,GAASnH,CAAO,EAAE,QAAQ,CAACmI,MAAS;AACvD,kBAAI;AACA,gBAAAL,EAAM,WAAWK,GAAMA,EAAK,WAAW,SAAS,IACzCF,KAAe,IAChBH,EAAM,SAAS,MAAM;AAAA,cAC3D,SACmCtG,GAAO;AACV,wBAAQ,MAAM,wCAAwC;AAAA,kBAClD,MAAA2G;AAAA,kBACA,OAAA3G;AAAA,gBACpC,CAAiC;AAAA,cACjC;AAAA,YACA,CAAyB,CAAC,EACG,MAAM,CAAC4G,MAAM;AACd,sBAAQ,MAAM,4BAA4BA,EAAE,SAAQ,CAAE;AAAA,YAClF,CAAyB;AACD,YAAA5B,EAAU,KAAKvD,CAAQ;AAAA,UAC/C;AAAA,QACA,CAAiB;AAAA,MACjB,SACmBmF,GAAG;AACN,cAAMC,IAAST,EAAY,KAAK,CAACjL,MAAMA,EAAE,QAAQ,IAAI,KAAK,SAAS,YAAY,CAAC;AAChF,QAAImL,EAAM,QAAQ,QACdtB,EAAU,KAAKK,GAASiB,EAAM,IAAI,EAC7B,KAAK,CAACI,MAAapB,GAAWoB,GAAUnK,CAAO,CAAC,EAChD,KAAK,CAACiC,MAAYmH,GAASnH,CAAO,EAAE,QAAQ,CAACmI,MAAS;AACvD,UAAAE,EAAO,WAAWF,GAAML,EAAM,SAAS,MAAM;AAAA,QACrE,CAAqB,CAAC,EACG,MAAM,CAACQ,MAAQ;AAChB,kBAAQ,MAAM,mCAAmCA,CAAG;AAAA,QAC5E,CAAqB,CAAC,GAEN,QAAQ,MAAM,kCAAkCF,CAAC;AAAA,MACjE;AAAA,EAEA,CAAK,GACM,QAAQ,IAAI5B,CAAS,EAAE,KAAK,OAE/BoB,EAAY,QAAQ,CAACE,MAAU;AAC3B,QAAI,cAAcA;AACd,UAAI;AACA,QAAA/K,EAAQ+K,EAAM,YAAY,CAAE,CAAA,EAAE,QAAQ,CAACC,MAAS;AAC5C,UAAAF,EAAI,KAAKE,CAAI;AAAA,QACrC,CAAqB;AAAA,MACrB,SACuBK,GAAG;AACN,gBAAQ,MAAM,sCAAsCN,EAAM,IAAI,IAAIM,CAAC;AAAA,MACvF;AAAA,EAEA,CAAS,GACMP,EACV;AACL;AACA,SAASU,GAAgBC,GAAU;AAC/B,SAAOA,EACF,OAAO,CAACL,MAASA,EAAK,SAAS,QAAQ,cAAc,EACrD,OAAO,CAACA,MAASxC,GAAYwC,EAAK,MAAM,iBAAiB,KAAK,CAAC,CAAC;AACzE;AACA,eAAeM,GAAkBrL,GAAMW,GAAS;AAC5C,MAAIX,EAAK,iBAAiB;AACtB,UAAM,IAAI,MAAM,2CAA2C;AAE/D,QAAMwK,IAAc7K,EAAQK,EAAK,cAAc,WAAW,GACpDoL,IAAW,MAAMb,GAAYC,GAAa7J,CAAO;AACvD,SAAOwK,GAAgBC,CAAQ;AACnC;AACO,eAAeE,GAActL,GAAMW,GAAS;AAC/C,QAAM4K,IAAQ,MAAMF,GAAkBrL,GAAMW,CAAO;AAKnD,UAJiB,MAAM,QAAQ,IAAI4K,EAAM,IAAI,CAACR,MAAS;AACnD,UAAM3L,IAAU2L,EAAK,mBAAmBA,EAAK,iBAAiB,OAAO;AACrE,WAAOvC,GAAeuC,EAAK,SAAS3L,GAASuB,CAAO;AAAA,EAC5D,CAAK,CAAC,GACc,KAAK;AAAA,CAAI;AAC7B;AACO,eAAe6K,GAAczI,GAAYpC,GAAS;AACrD,QAAMiC,IAAUjC,EAAQ,gBAAgB,OAClCA,EAAQ,eACRA,EAAQ,YACJ,OACA,MAAM2K,GAAcvI,GAAYpC,CAAO;AACjD,MAAIiC,GAAS;AACT,UAAM6I,IAAY,SAAS,cAAc,OAAO,GAC1CC,IAAe,SAAS,eAAe9I,CAAO;AACpD,IAAA6I,EAAU,YAAYC,CAAY,GAC9B3I,EAAW,aACXA,EAAW,aAAa0I,GAAW1I,EAAW,UAAU,IAGxDA,EAAW,YAAY0I,CAAS;AAAA,EAE5C;AACA;AC9KO,eAAeE,GAAM3L,GAAMW,IAAU,IAAI;AAC5C,QAAM,EAAE,OAAAC,GAAO,QAAAC,EAAM,IAAKJ,GAAaT,GAAMW,CAAO,GAC9CoC,IAAc,MAAMwC,GAAUvF,GAAMW,GAAS,EAAI;AACvD,eAAM6K,GAAczI,GAAYpC,CAAO,GACvC,MAAM0I,GAAYtG,GAAYpC,CAAO,GACrC2I,GAAWvG,GAAYpC,CAAO,GACd,MAAMgB,GAAcoB,GAAYnC,GAAOC,CAAM;AAEjE;AACO,eAAe+K,GAAS5L,GAAMW,IAAU,IAAI;AAC/C,QAAM,EAAE,OAAAC,GAAO,QAAAC,EAAM,IAAKJ,GAAaT,GAAMW,CAAO,GAC9Cc,IAAM,MAAMkK,GAAM3L,GAAMW,CAAO,GAC/BY,IAAM,MAAMH,EAAYK,CAAG,GAC3BN,IAAS,SAAS,cAAc,QAAQ,GACxC0K,IAAU1K,EAAO,WAAW,IAAI,GAChCJ,IAAQJ,EAAQ,cAAcG,GAAe,GAC7CgL,IAAcnL,EAAQ,eAAeC,GACrCmL,IAAepL,EAAQ,gBAAgBE;AAC7C,SAAAM,EAAO,QAAQ2K,IAAc/K,GAC7BI,EAAO,SAAS4K,IAAehL,GAC1BJ,EAAQ,iBACTO,GAAsBC,CAAM,GAEhCA,EAAO,MAAM,QAAQ,GAAG2K,CAAW,IACnC3K,EAAO,MAAM,SAAS,GAAG4K,CAAY,IACjCpL,EAAQ,oBACRkL,EAAQ,YAAYlL,EAAQ,iBAC5BkL,EAAQ,SAAS,GAAG,GAAG1K,EAAO,OAAOA,EAAO,MAAM,IAEtD0K,EAAQ,UAAUtK,GAAK,GAAG,GAAGJ,EAAO,OAAOA,EAAO,MAAM,GACjDA;AACX;;;;;;;;;;;;;;;;;;;ACNO,MAAe6K,GAAa;AAEnC;AVhCO,IAAAC,GAAAC,GAAAC;AWIA,MAAMC,WAA2BJ,GAAa;AAAA,EAGjD,YAAYK,GAA0B;AAC5B,UAAA;AAHV,IAAAC,EAAA,MAAAL;AAOA,IAAAK,EAAA,MAAAJ;AAkCA,IAAAI,EAAA,MAAAH;AAlCsB,IAAAI,EAAA,MAAAL,GAAA,CAACM,GAA4BC,IAAoB,QAAQ;AACrE,YAAAC,IAAgBC,EAAA,MAAKV,GAAa,iBAAiB;AAEzD,UAAI,CAACS,EAAe;AAEpB,YAAMZ,IAAcY,EAAc,OAC5BX,IAAgBD,IAAc,IAAK,IACnCc,IAAI,KAAK,IAAI,GAAGJ,EAAc,sBAAsB,EAAE,MAAM,OAAO,UAAUT,IAAe,CAAC,GAE7Fc,IAAcJ,IAAY,IAAK,IAE/BK,IAAa,SAAS,cAAc,QAAQ;AAClD,MAAAA,EAAW,QAAQL,GACnBK,EAAW,SAASD;AAEd,YAAA3H,IAAM4H,EAAW,WAAW,IAAI;AAClC,aAAC5H,KAGDA,EAAA;AAAA,QACAwH;AAAA,QACA;AAAA,QACA,KAAK,IAAI,GAAG,KAAK,IAAIE,GAAGF,EAAc,SAASX,CAAY,CAAC;AAAA;AAAA,QAC5DD;AAAA,QACAC;AAAA,QACA;AAAA,QACA;AAAA,QACAU;AAAA,QACAI;AAAA,MACJ,GAEOC,EAAW,UAAU,KAfX;AAAA,IAgBrB,IAEAP,EAAA,MAAAJ,GAAiB,CAACY,MAAoB;AAC5B,YAAAC,IAAM,SAAS,cAAc,KAAK;AACpC,MAAAA,EAAA,UAAU,IAAIC,EAAO,4BAA4B;AAE/C,YAAA1L,IAAM,IAAI,MAAM;AAEtB,aAAAA,EAAI,MAAMwL,GAEVC,EAAI,YAAYzL,CAAG,GACZyL;AAAA,IACX,IAEA,KAAO,wBAAwB,CAC3BE,GACAV,GACAW,MACC;AACG,UAAA,CAACX,EAAc,YAAa;AAC1B,YAAAY,IAAkB,SAAS,cAAc,KAAK,GAC9CC,IAAsB,SAAS,cAAc,GAAG;AAEtD,UAAIV,EAAA,MAAKV,GAAa,kBAAkB,EAAE,YAAY;AAC5C,cAAAc,IAAUJ,EAAA,MAAKT,GAAL,WAAyBM;AAEzC,YAAIO,GAAS;AACH,gBAAAO,IAAUX,EAAA,MAAKR,GAAL,WAAoBY;AACpC,UAAAK,EAAgB,YAAYE,CAAO;AAAA,QAAA;AAAA,MACvC;AAGY,MAAAF,EAAA,UAAU,IAAIH,EAAO,4BAA4B,GACjEG,EAAgB,UAAU,IAAIH,EAAO,gCAAgCE,CAAS,EAAE,CAAC,GAEjFE,EAAoB,cAAcb,EAAc,aAEhDY,EAAgB,YAAYC,CAAmB,GAE/C,KAAK,uBAAuB,GAE5BH,EAAgB,YAAYE,CAAe;AAAA,IAC/C,GA7EIb,EAAA,MAAKN,GAAeI;AAAA,EAAA;AAAA,EA+Ed,yBAAyB;AXxFhC,QAAA/G,GAAAK,GAAA4H,GAAAC,GAAAC,GAAAC;AWyFO,UAAAC,IAAiBhB,EAAA,MAAKV,GAAa,kBAAkB;AAGvD,QAAA0B,KAAkBA,EAAe,gBAAgB;AAC3C,YAAA,EAAE,YAAAC,GAAY,WAAAC,GAAW,UAAAC,GAAU,cAAAC,GAAc,eAAAC,GAAe,OAAApN,MAAU+M,EAAe;AAE/F,MAAIC,OACAtI,IAAAqH,EAAA,MAAKV,GAAa,wBAAwB,MAA1C,QAAA3G,EAA6C,MAAM,YAAY,oCAAoCsI,KAEnGC,OACAlI,IAAAgH,EAAA,MAAKV,GAAa,wBAAwB,MAA1C,QAAAtG,EAA6C,MAAM,YAAY,oCAAoCkI,KAEnGC,OACKP,IAAAZ,EAAA,MAAAV,GAAa,8BAAb,QAAAsB,EAAwC,MAAM,YAAY,mCAAmC,GAAGO,CAAQ,QAE7GC,OACKP,IAAAb,EAAA,MAAAV,GAAa,8BAAb,QAAAuB,EAAwC,MAAM,YAAY,uCAAuC,GAAGO,CAAY,QAErHC,OACKP,IAAAd,EAAA,MAAAV,GAAa,8BAAb,QAAAwB,EAAwC,MAAM,YAAY,wCAAwC,GAAGO,CAAa,QAEvHpN,OACK8M,IAAAf,EAAA,MAAAV,GAAa,8BAAb,QAAAyB,EAAwC,MAAM,YAAY,+BAA+B,GAAG9M,CAAK;AAAA,IAC1G;AAAA,EACJ;AAER;AA9GIqL,IAAA,eAOAC,IAAA,eAkCAC,IAAA;AX9CG,IAAAF,GAAAgC,GAAAC,IAAAC;AYKA,MAAMC,WAA4BpC,GAAa;AAAA,EAGlD,YAAYK,GAA0B;AAC5B,UAAA;AAJP,IAAAC,EAAA,MAAA4B;AACH,IAAA5B,EAAA,MAAAL;AAOA,IAAAK,EAAA,MAAA2B;AAAA,IAAA1B,EAAA,MAAA0B,GAAwB,CAACI,MAAwC;AAC7D,YAAMC,IAAyB,CAAC,GAE1BC,IAAW,CAACC,MAAoB;AAClC,QAAIA,EAAG,QAAQ,YAAY,MAAM,QACzBC,GAAA,MAAKP,IAAAC,IAAL,WAAuBK,MACvBF,EAAQ,KAAKE,CAAwB,GAI7C,MAAM,KAAKA,EAAG,QAAQ,EAAE,QAAQ,CAAC1I,MAAU;AACvC,UAAAyI,EAASzI,CAAoB;AAAA,QAAA,CAChC;AAAA,MACL;AAEA,aAAAyI,EAASF,CAAO,GAETC;AAAA,IACX,IAsBO,KAAA,iBAAiB,CAACI,MAA+C;AZrDrE,UAAApJ;AYsDO,YAAAqJ,IAAkBhC,EAAA,MAAKV,GAAa,mBAAmB;AACzD,UAAA,CAAC0C,EAAwB,QAAA;AAEvB,YAAAnC,IAAgBG,EAAA,MAAKsB,GAAL,WAA2BU;AAE7C,UAAAnC,EAAc,WAAW,EAAU,QAAA;AAGvC,YAAMoC,MAAgBtJ,IAAAqH,EAAA,MAAKV,GAAa,kBAAkB,EAAE,oBAAtC,gBAAA3G,EAAuD,UAAS;AACtF,UAAIuJ,IAAkBrC,EAAc;AAEtB,aAAAA,EAAA,IAAI,CAAC6B,MAAY;AZjEhC,YAAA/I;AYkEW,cAAAwJ,IAAkBnC,EAAA,MAAKV,GAAa,mBAAmB;AAE7D,YAAI,CAAC6C,EAAiB;AAEhB,cAAA5B,IAAkB,SAAS,cAAc,KAAK;AACpC,QAAAA,EAAA,UAAU,IAAID,EAAO,oBAAoB;AAEzD,cAAM8B,IAAqBV,EAAQ,sBAAsB,EAAE,MAAM,OAAO,SAClEW,IAAuBF,EAAgB,sBAAsB,EAAE,MAAM,OAAO,SAC5EG,IAAoBF,IAAqBC,GACzCE,KAAmBJ,EAAgB,eAAe,SAAS,gBAAgB;AAQjF,YANgB5B,EAAA,MAAM,SAASwB,EAAc,SAAS,GAEtCxB,EAAA,iBAAiB,SAAS,MAAM;AAC5C,UAAAmB,EAAQ,eAAe,EAAE,UAAU,SAAA,CAAU;AAAA,QAAA,CAChD,GAEGa,KAAmBH,GAAoB;AACjC,gBAAAI,IAAoBF,IAAoBC,KAAoB;AAElD,UAAAhC,EAAA,MAAM,OAAO,GAAGiC,IAAmB,MAAM,eAAeP,CAAa,QAAQ,GAAGO,CAAgB,GAAG,IAE/GxC,EAAA,MAAKV,GAAa,kBAAkB,EAAE,cACtB,IAAIG,GAAmBO,EAAA,MAAKV,EAAY,EAEhD,sBAAsBiB,GAAiBmB,GAASc,IAAmB,MAAM,SAAS,QAAQ;AAAA,QACtG;AAEA,UAAAjC,EAAgB,MAAM,OAAO,eAAe0B,KAAiBC,MAAoB,EAAE,OAE/ElC,EAAA,MAAKV,GAAa,kBAAkB,EAAE,cACtB,IAAIG,GAAmBO,EAAA,MAAKV,EAAY,EAEhD,sBAAsBiB,GAAiBmB,GAAS,OAAO;AAIvE,SAAA/I,KAAAqH,EAAA,MAAKV,GAAa,8BAAlB,QAAA3G,GAA6C,YAAY4H;AAAA,MACpB,CACxC,GAED,KAAK,uBAAuB,GAErB;AAAA,IACX,GArGIX,EAAA,MAAKN,GAAeI;AAAA,EAAA;AAAA,EAuGjB,yBAAyB;AZjH7B,QAAA/G,GAAAK;AYkHO,UAAAgI,IAAiBhB,EAAA,MAAKV,GAAa,kBAAkB;AAEvD,QAAA0B,KAAkBA,EAAe,iBAAiB;AAClD,YAAM,EAAE,OAAAyB,GAAO,OAAAxO,EAAM,IAAI+M,EAAe;AAExC,MAAIyB,OACA9J,IAAAqH,EAAA,MAAKV,GAAa,wBAAwB,MAA1C,QAAA3G,EAA6C,MAAM,YAAY,gCAAgC8J,KAE/FxO,OACK+E,IAAAgH,EAAA,MAAAV,GAAa,8BAAb,QAAAtG,EAAwC,MAAM,YAAY,gCAAgC,GAAG/E,CAAK;AAAA,IAC3G;AAAA,EACJ;AAER;AAzHIqL,IAAA,eAOAgC,IAAA,eARGC,KAAA,eA4BHC,cAAkBE,GAA+B;AAEvC,QAAAnM,IAAQ,OAAO,iBAAiBmM,CAAO;AAGzC,MAFAnM,EAAM,YAAY,UAClBA,EAAM,eAAe,YACrBA,EAAM,YAAY,IAAY,QAAA;AAGlC,MAAImN,IAAqChB,EAAQ;AACjD,SAAOgB,KAAgB;AACb,UAAAC,IAAc,OAAO,iBAAiBD,CAAc;AAGtD,QAFAC,EAAY,YAAY,UACxBA,EAAY,eAAe,YAC3BA,EAAY,YAAY,IAAY,QAAA;AACxC,IAAAD,IAAiBA,EAAe;AAAA,EAAA;AAG7B,SAAA;AAAA;AZlDR,IAAAE,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC,GAAAC;AaKA,MAAMC,WAAoB9E,GAAa;AAAA,EAmB1C,YAAYrL,GAA6B;AAC/B,UAAA;AAnBV,IAAA2L,EAAA,MAAAiD;AACA,IAAAjD,EAAA,MAAAkD;AACA,IAAAlD,EAAA,MAAAmD;AACA,IAAAnD,EAAA,MAAAoD;AACA,IAAApD,EAAA,MAAAqD;AAEA,IAAArD,EAAA,MAAAsD;AAEA,IAAAtD,EAAA,MAAAuD;AAEA,IAAAvD,EAAA,MAAAwD;AACA,IAAAxD,EAAA,MAAAyD;AACA,IAAAzD,EAAA,MAAA0D;AACA,IAAA1D,EAAA,MAAA2D;AACA,IAAA3D,EAAA,MAAA4D;AAEA,IAAA5D,EAAA,MAAA6D;AA4BA,IAAA7D,EAAA,MAAA8D;AAmCA,IAAA9D,EAAA,MAAA+D;AAwBA,IAAA/D,EAAA,MAAAgE;AASA,IAAAhE,EAAA,MAAAiE;AAgBA,IAAAjE,EAAA,MAAAkE;AAuBA,IAAAlE,EAAA,MAAAmE;AAcA,IAAAnE,EAAA,MAAAoE;AAEA,IAAApE,EAAA,MAAAqE;AAMA,IAAArE,EAAA,MAAAsE;AAqCA,IAAAtE,EAAA,MAAAuE;AAtKA,IAAAtE,EAAA,MAAA6D,GAAsB,MAAM;AACpB,UAAA,CAACzD,EAAA,MAAK6C;AACA,cAAA,IAAI,MAAM,8BAA8B;AAGlD,MAAAjD,EAAA,MAAKoD,GAAkB,IAAI,eAAe,OAAOoB,MAAY;AAGrD,YAFA,CAACpE,EAAA,MAAK6C,MAEN,CAAC7C,EAAA,MAAK8C,MAAyB9C,EAAA,MAAKmD,OAAqBiB,EAAQ,CAAC,EAAE,YAAY,OAAQ;AAE5F,QAAAxE,EAAA,MAAKuD,GAAmBiB,EAAQ,CAAC,EAAE,YAAY;AAE/C,cAAMC,IAAY,SAAS,OAAO,iBAAiBrE,EAAA,MAAK6C,EAAgB,EAAE,SAAS,GAC7EyB,IAAe,SAAS,OAAO,iBAAiBtE,EAAA,MAAK6C,EAAgB,EAAE,YAAY;AAMrF,YALJjD,EAAA,MAAK0D,GAAc,OAAO,UAAUtD,EAAA,MAAK6C,GAAiB,wBAAwB,MAClFjD,EAAA,MAAKyD,GAAerD,EAAA,MAAK6C,GAAiB,eAAewB,IAAYC,IAAe,SAAS,gBAAgB,eAE7GtE,EAAA,MAAK6D,GAAL,YAEI7D,EAAA,MAAK4C,GAAgB,aAAa;AACzB,mBAAA,iBAAiB,IAAItC,EAAO,oBAAoB,EAAE,EAAE,QAAQ,CAACoB,MAAY;AAC9E,YAAAA,EAAQ,OAAO;AAAA,UAAA,CAClB,GAEG1B,EAAA,MAAK4C,GAAgB,cACrB,MAAM5C,EAAA,MAAKiE,GAAL;AAGJ,gBAAAM,IAAW,IAAI9C,GAAoB,IAAI;AAE7C,UAAA7B,EAAA,MAAKqD,GAAoBsB,EAAS,eAAevE,EAAA,MAAKuD,EAAc;AAAA,QAAA;AAAA,MACxE,CACH;AAAA,IACL,IAEA3D,EAAA,MAAA8D,GAA8B,MAAM;AAC5B,UAAA;AACA,YAAI,CAAC1D,EAAA,MAAK6C,GAAwB,OAAA,IAAI,MAAM,8BAA8B;AAEpE,cAAA2B,IAAuB,SAAS,cAAc,KAAK;AACpC,QAAAA,EAAA,UAAU,IAAIlE,EAAO,qBAAqB;AAE/D,cAAMyB,IAAgB/B,EAAA,MAAK4D,GAAL,WAAwB5D,EAAA,MAAK6C;AACnD,QAAAjD,EAAA,MAAK2D,GAAiBxB,IACDyC,EAAA,MAAM,SAASzC,EAAc,SAAS;AAErD,cAAA0C,IAAiBzE,EAAA,MAAK2D,GAAL;AACvB,eAAAa,EAAqB,YAAYC,CAAc,GAE/C7E,EAAA,MAAKkD,GAAwB0B,IAE7B,KAAK,uBAAuB,GAErBA;AAAA,eACF/M,GAAO;AACZ,gBAAQ,MAAMA,CAAK;AAAA,MAAA;AAAA,IAE3B,IAEAmI,EAAA,MAAA+D,GAAwB,MAAM;AACpB,YAAAc,IAAiB,SAAS,cAAc,KAAK;AACpC,aAAAA,EAAA,UAAU,IAAInE,EAAO,eAAe,GAEnDV,EAAA,MAAKmD,GAAkB0B,IAEhBA;AAAA,IACX,IAEA7E,EAAA,MAAAgE,GAAqB,CAAClC,MAAyB;AAC3C,UAAIgD,IAAU;AAEd,YAAMC,IAAS,OAAO,iBAAiBjD,CAAO,EAAE;AAEhD,aAAIiD,MAAW,WACXD,IAAU,KAAK,IAAIA,GAAS,SAASC,CAAM,CAAC,IAGhD,MAAM,KAAKjD,EAAQ,QAAQ,EAAE,QAAQ,CAACvI,MAAU;AAC5C,QAAAuL,IAAU,KAAK,IAAIA,GAAS1E,EAAA,MAAK4D,GAAL,WAAwBzK,EAAqB;AAAA,MAAA,CAC5E,GAEMuL,IAAU;AAAA,IACrB,IAEA9E,EAAA,MAAAiE,GAAkB,MAAM;AAEhB,UADA,CAAC7D,EAAA,MAAK6C,MACN,CAAC7C,EAAA,MAAKwD,GAAW;AAIrB,UAAI,CAFyBxD,EAAA,MAAKgE,GAAL,YAEF;AAClB,QAAAhE,EAAA,MAAA8C,GAAuB,MAAM,UAAU;AAC5C;AAAA,MAAA;AAGC,MAAA9C,EAAA,MAAA8C,GAAuB,MAAM,UAAU;AAGtC,YAAA8B,KADgB,OAAO,UAAU5E,EAAA,MAAKsD,MACFtD,EAAA,MAAKqD,KAAgB;AAE1D,MAAAzD,EAAA,MAAAwD,GAAY,KAAK,IAAI,KAAK,KAAK,IAAI,GAAGwB,CAAgB,CAAC,IAExD5E,EAAA,MAAK+C,OACL/C,EAAA,MAAK+C,GAAgB,MAAM,QAAQ,GAAG/C,EAAA,MAAKoD,EAAS;AAAA,IAE5D,IAEYxD,EAAA,MAAAkE,GAAA,CAACe,GAAgBC,MAAkB;AAC3C,UAAIC,IAAsB;AAE1B,aAAO,MAAM;AACT,QAAKA,MACDF,EAAK,MAAM,IAAI,GACFE,IAAA,IACb,WAAW,MAAM;AACA,UAAAA,IAAA;AAAA,WACdD,CAAK;AAAA,MAEhB;AAAA,IACJ,IAEAlF,EAAA,MAAAmE,GAA2B/D,EAAA,MAAK8D,GAAL,WAAe9D,EAAA,MAAK6D,IAAiB,MAEhEjE,EAAA,MAAAoE,GAAwB,MACfhE,EAAA,MAAK6C,KAEH7C,EAAA,MAAK6C,GAAiB,sBAAA,EAAwB,OAAO,KAAK7C,EAAA,MAAK6C,GAAiB,sBAAsB,EAAE,SAAS,IAFrF,KAKvCjD,EAAA,MAAAqE,GAAoB,YAAY;AACxB,UAACjE,EAAA,MAAK6C;AAEN,YAAA;AAEA,gBAAMmC,IAAW,KAAK;AAAA,YAClB,SAAS,gBAAgB;AAAA,YACzB,SAAS,gBAAgB;AAAA,YACzB,SAAS,gBAAgB;AAAA,UAC7B,GACMC,IAAY,KAAK;AAAA,YACnB,SAAS,gBAAgB;AAAA,YACzB,SAAS,gBAAgB;AAAA,YACzB,SAAS,gBAAgB;AAAA,UAC7B;AAGA,gBAAM,IAAI,QAAQ,CAACvQ,MAAY,WAAWA,GAAS,GAAG,CAAC;AAEvD,gBAAMF,IAAS,MAAM0Q,GAAqB,SAAS,iBAAiB;AAAA,YAChE,OAAOF;AAAA,YACP,QAAQC;AAAA,YACR,QAAQ,CAAC5R,MAAS;AbzM3B,kBAAAsF;Aa0Ma,qBAAO,EAAEtF,aAAgB,iBAAesF,IAAAtF,EAAK,cAAL,QAAAsF,EAAgB,SAAS2H,EAAO;AAAA,YAC5E;AAAA,YACA,iBAAiB,iBAAiB,SAAS,IAAI,EAAE,mBAAmB;AAAA,UAAA,CACvE;AAED,iBAAAV,EAAA,MAAKsD,GAAiB1O,IAEfA;AAAA,iBACFiD,GAAO;AACJ,yBAAA,MAAM,oBAAoBA,CAAK,GAChC;AAAA,QAAA;AAAA,IAEf,IAEAmI,EAAA,MAAAsE,GAAqB,MAAM;AACnB,UAAA;AACA,YAAI,CAAClE,EAAA,MAAK6C,GAAwB,OAAA,IAAI,MAAM,8BAA8B;AAItE,YAFwB,SAAS,iBAAiB,IAAIvC,EAAO,qBAAqB,EAAE,EAEhE,SAAS;AACtB,iBAAA;AAGP,YAAA,CAACN,EAAA,MAAKgD;AACA,gBAAA,IAAI,MAAM,6BAA6B;AAG3C,cAAAmC,IAAYnF,EAAA,MAAK0D,GAAL;AAElB,YAAI,CAACyB,EAAiB,OAAA,IAAI,MAAM,mCAAmC;AAE9D,QAAAnF,EAAA,MAAA6C,GAAiB,YAAYsC,CAAS,GAEtCnF,EAAA,MAAAgD,GAAgB,QAAQhD,EAAA,MAAK6C,EAAgB,GAEjC,IAAI,qBAAqB,CAACuB,MAAY;AAC3C,UAAAA,EAAA,QAAQ,CAACgB,MAAU;AACvB,YAAIA,EAAM,kBACNxF,EAAA,MAAK4D,GAAY,KACjBxD,EAAA,MAAK6D,GAAL,cAEAjE,EAAA,MAAK4D,GAAY;AAAA,UACrB,CACH;AAAA,QAAA,CACJ,EAEQ,QAAQxD,EAAA,MAAK6C,EAAgB,GAE/B,OAAA,iBAAiB,UAAU7C,EAAA,MAAK+D,EAAwB;AAAA,eAC1DtM,GAAO;AACZ,gBAAQ,MAAMA,CAAK;AAAA,MAAA;AAAA,IAE3B,IAEA,KAAU,yBAAyB,MAAM;AACjC,UAACuI,EAAA,MAAK8C,MAEN9C,EAAA,MAAK4C,GAAgB,YAAY;AACjC,cAAM,EAAE,OAAAH,GAAO,YAAAxB,GAAY,QAAA/M,EAAO,IAAI8L,EAAA,MAAK4C,GAAgB;AAC3D,QAAIH,KACAzC,EAAA,MAAK8C,GAAsB,MAAM,YAAY,2BAA2BL,CAAK,GAE7ExB,KACAjB,EAAA,MAAK8C,GAAsB,MAAM,YAAY,gCAAgC7B,CAAU,GAEvF/M,KACA8L,EAAA,MAAK8C,GAAsB,MAAM,YAAY,4BAA4B,GAAG5O,CAAM,IAAI;AAAA,MAC1F;AAAA,IAER,GAEA,KAAO,qBAAqB,MACjB8L,EAAA,MAAK6C,IAGhB,KAAO,0BAA0B,MACtB7C,EAAA,MAAK8C,IAGhB,KAAO,mBAAmB,MACf9C,EAAA,MAAKkD,MAAkB,MAGlC,KAAO,oBAAoB,MAChBlD,EAAA,MAAK4C,IAGT,KAAA,yBAAyB,CAAC5O,MAAgC;AblS9D,UAAA2E;Aa0SC,UAPAiH,EAAA,MAAKgD,GAAkB5O,IAEvB,KAAK,uBAAuB,IAE5B2E,IAAAqH,EAAA,MAAKiD,OAAL,QAAAtK,EAAwB,0BAGpBqH,EAAA,MAAK4C,MAAmB5C,EAAA,MAAK4C,GAAgB,gBAAgB;AACvD,cAAA,EAAE,YAAA3B,GAAY,WAAAC,GAAW,UAAAC,GAAU,cAAAC,GAAc,eAAAC,GAAe,OAAApN,EAAU,IAAA+L,EAAA,MAAK4C,GAAgB;AAErG,QAAI3B,KACAjB,EAAA,MAAK8C,GAAsB,MAAM,YAAY,oCAAoC7B,CAAU,GAE3FC,KACAlB,EAAA,MAAK8C,GAAsB,MAAM,YAAY,oCAAoC5B,CAAS,GAE1FC,KACAnB,EAAA,MAAK8C,GAAsB,MAAM,YAAY,mCAAmC,GAAG3B,CAAQ,IAAI,GAE/FC,KACApB,EAAA,MAAK8C,GAAsB,MAAM,YAAY,uCAAuC,GAAG1B,CAAY,IAAI,GAEvGC,KACArB,EAAA,MAAK8C,GAAsB,MAAM,YAAY,wCAAwC,GAAGzB,CAAa,IAAI,GAEzGpN,KACA+L,EAAA,MAAK8C,GAAsB,MAAM,YAAY,+BAA+B,GAAG7O,CAAK,IAAI;AAAA,MAC5F;AAAA,IAER;AAtSU,UAAA,EAAE,UAAAoR,MAAarR;AACrB,IAAA4L,EAAA,MAAKgD,GAAkB5O,IAEvB4L,EAAA,MAAKiD,GAAmB,SAAS,eAAewC,CAAQ,KAAK,OAC7DzF,EAAA,MAAKkD,GAAwB,OAC7BlD,EAAA,MAAKmD,GAAkB,OACvBnD,EAAA,MAAKoD,GAAkB,OACvBpD,EAAA,MAAKsD,GAAiB,OACtBtD,EAAA,MAAKqD,GAAoB,OAGzBrD,EAAA,MAAKuD,GAAmB,IACxBvD,EAAA,MAAKwD,GAAY,IACjBxD,EAAA,MAAKyD,GAAe,IACpBzD,EAAA,MAAK0D,GAAc,IACnB1D,EAAA,MAAK2D,GAAiB,IAEtB3D,EAAA,MAAK4D,GAAY,KAEjBxD,EAAA,MAAKyD,GAAL,YAEAzD,EAAA,MAAKkE,GAAL;AAAA,EAAwB;AAkRhC;AA3TItB,IAAA,eACAC,IAAA,eACAC,IAAA,eACAC,IAAA,eACAC,IAAA,eAEAC,IAAA,eAEAC,IAAA,eAEAC,IAAA,eACAC,IAAA,eACAC,IAAA,eACAC,IAAA,eACAC,IAAA,eAEAC,IAAA,eA4BAC,IAAA,eAmCAC,IAAA,eAwBAC,IAAA,eASAC,IAAA,eAgBAC,IAAA,eAuBAC,IAAA,eAcAC,IAAA,eAEAC,IAAA,eAMAC,IAAA,eAqCAC,IAAA;ACrNS,MAAAoB,KAAoB,CAACtR,MAAoD;AAC9E,MAAA;AACO,WAAA,IAAImQ,GAAYnQ,CAAO;AAAA,WACzByD,GAAO;AACZ,mBAAQ,MAAMA,CAAK,GACZ;AAAA,EAAA;AAEf;","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9]}